* Java Debugger

** jbug mode

#+BEGIN_SRC emacs-lisp :tangle jbug.el

(require 'bm)
(require 'dash)
(require 'ht)
(require 's)

(defvar jbug-mode-map
  (let ((map (make-sparse-keymap)))
    (define-key map (kbd "RET") 'jbug-newline)
    (define-key map (kbd "M-p") 'jbug-commandring)
    map))

(define-derived-mode jbug-mode
  org-mode "Jbug"
  "Major mode java debugger.")

(defvar defaultThread "" "the last thread in which we had a breakpoint. use this thread if no thread number is specified in a command")

#+END_SRC

** The Proxy

#+BEGIN_SRC emacs-lisp :tangle jbug.el
(defvar proxyProcess () "the JAVA proxy program which connects to the program to be debugged")
#+END_SRC

*** Start the proxy

The proxy runs as a sub process to emacs. The proxy connects to the target
process and handles the JDI interface. This elisp program sends commands to the
proxy on stdin and receives replies on stdout.

#+BEGIN_SRC emacs-lisp :noweb-ref start-proxy
(defcustom jbug-proxy
  "java -cp ~/jbug/src/main/java/com/github/jruby21/jbug/JbuggerProxy:~/jdk1.8.0_131/lib/tools.jar com.github.jruby21.jbug.JbugProxy"
  "full command to run jbug proxy"
  :type '(string)
  :group 'jbug)
#+END_SRC

Start the proxy and set the filter which handles strings received on stdin from
the proxy.  There is a special command (proxy) that does nothing but wait for
the proxy to signal that it has started.

#+BEGIN_SRC emacs-lisp :noweb-ref start-proxy

(setq proxyProcess (apply 'start-process "jbugProxy"  (current-buffer) (split-string jbug-proxy)))
(set-process-filter proxyProcess 'jbug-insertion-filter)

(setq commandsToRun ())

(setq runningCommand
      (jbug-describeRunnableCommand
       "proxy"
       "proxy"
       (list "proxy")
       (jbug-makeCommandHashEntry
        "proxy"
        (lambda (c) ())
        ""
        (lambda (c) "")
        (list jbug-proxyStarted-response))))

#+END_SRC


#+BEGIN_SRC emacs-lisp :tangle jbug.el

;; breakpointCleared
(defconst jbug-breakpointCleared-response "breakpointcleared" "")
(defvar jbug-breakpointCleared-hook nil)
(setq jbug-breakpointCleared-hook ())
(ht-set jbug-response-hooks
   jbug-breakpointCleared-response
   (lambda (response) (run-hook-with-args 'jbug-breakpointCleared-hook (nth 1 response))))

;; breakpointCreated
(defconst jbug-breakpointCreated-response "breakpointcreated" "")
(defvar jbug-breakpointCreated-hook nil)
(setq jbug-breakpointCreated-hook ())
(ht-set jbug-response-hooks
   jbug-breakpointCreated-response
   (lambda (response) (run-hook-with-args 'jbug-breakpointCreated-hook (nth 1 response) (-slice response 2 5))))

;; breakpointEntered
(defconst jbug-breakpointEntered-response "breakpointentered" "")
(defvar jbug-breakpointEntered-hook nil)
(setq jbug-breakpointEntered-hook ())
(ht-set jbug-response-hooks
   jbug-breakpointEntered-response
   (lambda (response) (run-hook-with-args 'jbug-breakpointEntered-hook (nth 1 response) (-slice response 2 8) (-slice response 8))))

;; breakpointList
(defconst jbug-breakpointList-response "breakpointlist" "")
(defvar jbug-breakpointList-hook nil)
(setq jbug-breakpointList-hook ())
(ht-set jbug-response-hooks
   jbug-breakpointList-response
   (lambda (response) (run-hooks 'jbug-breakpointList-hook )))

;; classPrepared
(defconst jbug-classPrepared-response "classprepared" "")
(defvar jbug-classPrepared-hook nil)
(setq jbug-classPrepared-hook ())
(ht-set jbug-response-hooks
   jbug-classPrepared-response
   (lambda (response) (run-hook-with-args 'jbug-classPrepared-hook (nth 1 response))))

;; classUnloaded
(defconst jbug-classUnloaded-response "classunloaded" "")
(defvar jbug-classUnloaded-hook nil)
(setq jbug-classUnloaded-hook ())
(ht-set jbug-response-hooks
   jbug-classUnloaded-response
   (lambda (response) (run-hook-with-args 'jbug-classUnloaded-hook (nth 1 response))))

;; error
(defconst jbug-error-response "error" "")
(defvar jbug-error-hook nil)
(setq jbug-error-hook ())
(ht-set jbug-response-hooks
   jbug-error-response
   (lambda (response) (run-hook-with-args 'jbug-error-hook (nth 1 response))))

;; exception
(defconst jbug-exception-response "exception" "")
(defvar jbug-exception-hook nil)
(setq jbug-exception-hook ())
(ht-set jbug-response-hooks
   jbug-exception-response
   (lambda (response) (run-hook-with-args 'jbug-exception-hook (nth 1 response) (-slice response 2 5)(nth 5 response))))

;; internalException
(defconst jbug-internalException-response "internalexception" "")
(defvar jbug-internalException-hook nil)
(setq jbug-internalException-hook ())
(ht-set jbug-response-hooks
   jbug-internalException-response
        (lambda (response) (run-hook-with-args 'jbug-internalException-hook (nth  1 response) (nth 2 response))))

;; log
(defconst jbug-log-response "log" "")
(defvar jbug-log-hook nil)
(setq jbug-log-hook ())
(ht-set jbug-response-hooks
   jbug-log-response
   (lambda (response) (run-hook-with-args 'jbug-log-hook (nth 1 response))))

;; locals
(defconst jbug-locals-response "locals" "")
(defvar jbug-locals-hook nil)
(setq jbug-locals-hook ())
(ht-set jbug-response-hooks
   jbug-locals-response
   (lambda (response) (run-hooks 'jbug-locals-hook )))

;; proxyExited
(defconst jbug-proxyExited-response "proxyexited" "")
(defvar jbug-proxyExited-hook nil)
(setq jbug-proxyExited-hook ())
(ht-set jbug-response-hooks
   jbug-proxyExited-response
   (lambda (response) (run-hooks 'jbug-proxyExited-hook )))

;; proxyStarted
(defconst jbug-proxyStarted-response "proxystarted" "")
(defvar jbug-proxyStarted-hook nil)
(setq jbug-proxyStarted-hook ())
(ht-set jbug-response-hooks
   jbug-proxyStarted-response
   (lambda (response) (run-hooks 'jbug-proxyStarted-hook )))

;; stack - variable number of location triplets
(defconst jbug-stack-response "stack" "")
(defvar jbug-stack-hook nil)
(setq jbug-stack-hook ())
(ht-set jbug-response-hooks
   jbug-stack-response
   (lambda (response) (run-hook-with-args 'jbug-stack-hook (nth 1 response) (-partition-in-steps 3 3 (-slice response 2)))))

;; step
(defconst jbug-step-response "step" "")
(defvar jbug-step-hook nil)
(setq jbug-step-hook ())
(ht-set jbug-response-hooks
   jbug-step-response
   (lambda (response) (run-hook-with-args 'jbug-step-hook  (-slice response 1 6) (-slice response 6 9))))

;; stepCreated
(defconst jbug-stepCreated-response "stepcreated" "")
(defvar jbug-stepCreated-hook nil)
(setq jbug-stepCreated-hook ())
(ht-set jbug-response-hooks
   jbug-stepCreated-response
   (lambda (response) (run-hooks 'jbug-stepCreated-hook )))

;; this
(defconst jbug-this-response "this" "")
(defvar jbug-this-hook nil)
(setq jbug-this-hook ())
(ht-set jbug-response-hooks
   jbug-this-response
   (lambda (response) (run-hooks 'jbug-this-hook )))

;; threadList
(defconst jbug-threadList-response "threadlist" "")
(defvar jbug-threadList-hook nil)
(setq jbug-threadList-hook ())
(ht-set jbug-response-hooks
   jbug-threadList-response
   (lambda (response) (run-hooks 'jbug-threadList-hook )))

;; threadDied
(defconst jbug-threadDied-response "threaddied" "")
(defvar jbug-threadDied-hook nil)
(setq jbug-threadDied-hook ())
(ht-set jbug-response-hooks
   jbug-threadDied-response
   (lambda (response) (run-hook-with-args 'jbug-threadDied-hook  (-slice response 1 6))))

;; threadStarted
(defconst jbug-threadStarted-response "threadstarted" "")
(defvar jbug-threadStarted-hook nil)
(setq jbug-threadStarted-hook ())
(ht-set jbug-response-hooks
   jbug-threadStarted-response
   (lambda (response) (run-hook-with-args 'jbug-threadStarted-hook  (-slice response 1 6))))

;; vmCreated
(defconst jbug-vmCreated-response "vmcreated" "")
(defvar jbug-vmCreated-hook nil)
(setq jbug-vmCreated-hook ())
(ht-set jbug-response-hooks
   jbug-vmCreated-response
   (lambda (response) (run-hooks 'jbug-vmCreated-hook )))

;; vmDied
(defconst jbug-vmDied-response "vmdied" "")
(defvar jbug-vmDied-hook nil)
(setq jbug-vmDied-hook ())
(ht-set jbug-response-hooks
   jbug-vmDied-response
   (lambda (response) (run-hooks 'jbug-vmDied-hook )))

;; vmDisconnected
(defconst jbug-vmDisconnected-response "vmdisconnected" "")
(defvar jbug-vmDisconnected-hook nil)
(setq jbug-vmDisconnected-hook ())
(ht-set jbug-response-hooks
   jbug-vmDisconnected-response
   (lambda (response) (run-hooks 'jbug-vmDisconnected-hook )))

;; vmResumed
(defconst jbug-vmResumed-response "vmresumed" "")
(defvar jbug-vmResumed-hook nil)
(setq jbug-vmResumed-hook ())
(ht-set jbug-response-hooks
   jbug-vmResumed-response
   (lambda (response) (run-hooks 'jbug-vmResumed-hook )))

;; vmStarted
(defconst jbug-vmStarted-response "vmstarted" "")
(defvar jbug-vmStarted-hook nil)
(setq jbug-vmStarted-hook ())
(ht-set jbug-response-hooks
   jbug-vmStarted-response
   (lambda (response) (run-hooks 'jbug-vmStarted-hook )))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle jbug.el
;; breakpointCleared
;;(add-hook 'jbug-breakpointCleared-hook (lambda ( breakId)

;; breakpointCreated
(add-hook 'jbug-breakpointCreated-hook
          (lambda ( breakId loc)
            (writeStringToBuffer proc (concat "Breakpoint  " breakId " created at " (jbug-LocationString loc)  ".\n"))))

;; breakpointEntered
(add-hook 'jbug-breakpointEntered-hook
          (lambda ( breakId tr loc)
            (reportBreak (concat "Breakpoint " breakId " entered") tr loc)))

;; breakpointList
;;(add-hook 'jbug-breakpointList-hook (lambda ()

;; classPrepared
(add-hook 'jbug-classPrepared-hook (lambda ( className)
            (writeStringToBuffer proc (concat "class " className " loaded.\n"))))

;; classUnloaded
;;(add-hook 'jbug-classUnloaded-hook (lambda ( className)

;; error
(add-hook 'jbug-error-hook (lambda ( error)
            (writeStringToBuffer proc (concat "Error: "  error "\n"))))

;; exception
(add-hook 'jbug-exception-hook (lambda ( name catch message)
            (writeStringToBuffer proc (concat "Exception received in proxy"))))

;; internalException
(add-hook 'jbug-internalException-hook
          (lambda (msg stack)
            (writeStringToBuffer proc (concat "Internal exception in proxy: " msg "\n" stack "\n"))))

;; log
;;(add-hook 'jbug-log-hook (lambda ( msg)

;; locals
;;(add-hook 'jbug-locals-hook (lambda ()

;; proxyExited
;;(add-hook 'jbug-proxyExited-hook (lambda ()

;; proxyStarted
(add-hook 'jbug-proxyStarted-hook (lambda ()
            (writeStringToBuffer proxyProcess "Debugger proxy started\n")))

;; stack
(add-hook 'jbug-stack-hook
          (lambda (id locations)
            (writeStringToBuffer proxyProcess (concat "Stack for thread " id " \n"))
            (dolist (l locations)
              (writeStringToBuffer proxyProcess (concat (jbug-LocationString l) "\n")))))

;; step
;;(add-hook 'jbug-step-hook (lambda ( tr loc)

;; stepCreated
;;(add-hook 'jbug-stepCreated-hook (lambda ()

;; this
;;(add-hook 'jbug-this-hook (lambda ()

;; threadList
;;(add-hook 'jbug-threadList-hook (lambda ()

;; threadDied
;;(add-hook 'jbug-threadDied-hook (lambda ( tr)

;; threadStarted
;;(add-hook 'jbug-threadStarted-hook (lambda ( tr)

;; vmCreated
(add-hook 'jbug-vmCreated-hook (lambda ()
        (writeStringToBuffer proxyProcess "virtual machine created\n")))

;; vmDied
(add-hook 'jbug-vmDied-hook (lambda ()
        (writeStringToBuffer proxyProcess "virtual machine terminated\n")))

;; vmDisconnected
(add-hook 'jbug-vmDisconnected-hook (lambda ()
        (writeStringToBuffer proxyProcess "virtual machine disconnected\n")))

;; vmResumed
(add-hook 'jbug-vmResumed-hook (lambda ()
        (writeStringToBuffer proxyProcess "virtual machine resuming operation.\n")))

;; vmStarted
(add-hook 'jbug-vmStarted-hook (lambda ()
              (writeStringToBuffer proxyProcess "virtual machine started\n")))


(defun jbug-LocationString (l) (format "%s:%s %s" (locationFile l) (locationLineNumber l) (locationMethod l)))


#+END_SRC

*** Commands Sent to the Proxy

**** Comands the Debugger Supports

A supported command is described by a CommandHashEntry

#+BEGIN_SRC emacs-lisp :tangle jbug.el
(defun jbug-makeCommandHashEntry (hashKey badCommandP describeCommand executeCommand proxyDoneP)
  (list hashKey badCommandP describeCommand executeCommand proxyDoneP))

(defun jbug-hashKey                        (hashEntry) (nth 0 hashEntry))
(defun jbug-hashBadCommandP       (hashEntry) (nth 1 hashEntry))
(defun jbug-hashDescribeCommand  (hashEntry) (nth 2 hashEntry))
(defun jbug-hashDoCommand          (hashEntry) (nth 3 hashEntry))
(defun jbug-hashProxyDoneP          (hashEntry) (nth 4 hashEntry))

(defun jbug-badCommandP    (e f)             (funcall (jbug-hashBadCommandP e) f))
(defun jbug-checkProxyDone  (e f)             (funcall (jbug-hashProxyDoneP e) f))
(defun jbug-doCommand       (e p f)          (funcall (jbug-hashDoCommand e) p f))

#+END_SRC

Support commands are kept in a hash table

#+BEGIN_SRC emacs-lisp :tangle jbug.el

(defconst commandHashMap
  ((lambda (x)
     (let ((h (ht-create)))
       (mapc
        (lambda (c) (ht-set h (jbug-hashKey c) c))
        x)
       h))
  (list
   (jbug-makeCommandHashEntry "arguments"
                               (lambda (c) (not (or (= (length c) 1)
                                                    (and (= (length c) 2) (string-match "[0-9]+" (nth 1 c)))
                                                    (and (= (length c) 3)  (string-match "[0-9]+" (nth 1 c))  (string-match "[0-9]+" (nth 2 c))))))
                               "arguments [thread-id] [frame number]"
                                (lambda (proxy c)
                                 (process-send-string
                                  proxy
                                  (format
                                   "frame,%s,%s\n"
                                   (if (= (length c) 1) defaultThread (nth 1 c))
                                   (if (or (= (length c) 1)  (= (length c) 2)) "0" (nth 2 c)))))
                               (lambda (r) (string= (car r) "arguments")))
   (jbug-makeCommandHashEntry "attach"
                               (lambda (c) (or (/= (length c) 3)  (not (string-match "[0-9]+" (nth 2 c)))))
                               "attach host  [port number ]"
                               (lambda (proxy c)
                                 (process-send-string
                                  proxy
                                  (format "attach,%s,%s\n" (nth 1 c) (nth 2 c))))
                               (list jbug-vmCreated-response jbug-error-response jbug-internalException-response))
   (jbug-makeCommandHashEntry "back"
                               (lambda (c) (or (> (length c) 2)  (and (= (length c) 2) (not (string-match "[0-9]+" (nth 1 c))))))
                               "back [thread-id]"
                               (lambda (proxy c)
                                 (process-send-string
                                  proxy
                                  (format
                                   "back,%s\n"
                                   (if (= (length c) 1) defaultThread (nth 1 c)))))
                               (lambda (r) (string= (car r) "step")))
   (jbug-makeCommandHashEntry "break"
                               (lambda (c) (/= (length c) 3))
                               "break class-name <line-number|method name>"
                               (lambda (proxy c)
                                 (process-send-string
                                  proxy
                                  (format "break,%s,%s\n" (nth 1 c) (nth 2 c))))
                               (list jbug-breakpointCreated-response jbug-error-response jbug-internalException-response))
   (jbug-makeCommandHashEntry "breaks"
                               (lambda (c) (/= (length c) 1))
                               "breaks"
                               (lambda (proxy c)
                                 (process-send-string
                                  proxy
                                  "breaks\n"))
                               (lambda (r) (string= (car r) "breakpoints")))
   (jbug-makeCommandHashEntry "clear"
                               (lambda (c) (or (/= (length c) 2)  (not (string-match "[0-9]+" (nth 1 c)))))
                               "clear [breakpoint-id]"
                               (lambda (proxy c)
                                 (process-send-string
                                  proxy
                                  (format
                                   "clear,%s\n"
                                   (nth 1 c))))
                               (lambda (r) (string= (car r) "step")))
   (jbug-makeCommandHashEntry "continue"
                               (lambda (c) (/= (length c) 1))
                               "continue"
                               (lambda (proxy c)
                                 (process-send-string
                                  proxy
                                  "continue\n"))
                               (list jbug-vmResumed-response jbug-error-response jbug-internalException-response))
   (jbug-makeCommandHashEntry "frame"
                               (lambda (c) (not (or (= (length c) 1)
                                                    (and (= (length c) 2) (string-match "[0-9]+" (nth 1 c)))
                                                    (and (= (length c) 3)  (string-match "[0-9]+" (nth 1 c))  (string-match "[0-9]+" (nth 2 c))))))
                               "frame [thread-id] [frame number]"
                               (lambda (proxy c)
                                 (process-send-string
                                  proxy
                                  (format
                                   "frame,%s,%s\n"
                                   (if (= (length c) 1) defaultThread (nth 1 c))
                                   (if (or (= (length c) 1)  (= (length c) 2)) "0" (nth 2 c)))))
                               (lambda (r) (string= (car r) "arguments")))
   (jbug-makeCommandHashEntry "help"
                               (lambda (c) ())
                               "help"
                               (lambda (proxy c)
                                 (dolist (v
                                          (sort (ht-map (lambda (key value) (jbug-hashDescribeCommand value)) commandHashMap) 'string<))
                                   (writeStringToBuffer proxy (concat v "\n")))
                                 (setq runningCommand ())
                                 (jbug-fix-output-buffer proxyProcess))
                               (lambda (r) (string= (car r) "help")))
   (jbug-makeCommandHashEntry "into"
                               (lambda (c) (or (> (length c) 2)  (and (= (length c) 2) (not (string-match "[0-9]+" (nth 1 c))))))
                               "into [thread-id]"
                               (lambda (proxy c)
                                 (process-send-string
                                  proxy
                                  (format
                                   "into,%s\n"
                                   (if (= (length c) 1) defaultThread (nth 1 c)))))
                               (lambda (r) (string= (car r) "step")))
   (jbug-makeCommandHashEntry "load"
                               (lambda (c) (/= (length c) 1))
                               "load"
                               (lambda (proxy c)
                                 (process-send-string
                                  proxy
                                  "run\n"))
                               (list  jbug-classPrepared-response jbug-error-response jbug-internalException-response))
   (jbug-makeCommandHashEntry "locals"
                               (lambda (c) (not (or (= (length c) 1)
                                                    (and (= (length c) 2) (string-match "[0-9]+" (nth 1 c)))
                                                    (and (= (length c) 3)  (string-match "[0-9]+" (nth 1 c))  (string-match "[0-9]+" (nth 2 c))))))
                               "locals [thread-id] [frame-number]"
                               (lambda (proxy c)
                                 (process-send-string
                                  proxy
                                  (format
                                   "frame,%s,%s\n"
                                   (if (= (length c) 1) defaultThread (nth 1 c))
                                   (if (or (= (length c) 1)  (= (length c) 2)) "0" (nth 2 c)))))
                               (lambda (r) (string= (car r) "locals")))
   (jbug-makeCommandHashEntry "next"
                               (lambda (c) (or (> (length c) 2)  (and (= (length c) 2) (not (string-match "[0-9]+" (nth 1 c))))))
                               "next [thread-id]"
                               (lambda (proxy c)
                                 (process-send-string
                                  proxy
                                  (format
                                   "next,%s\n"
                                   (if (= (length c) 1) defaultThread (nth 1 c)))))
                               (lambda (r) (string= (car r) "step")))
   (jbug-makeCommandHashEntry "prepare"
                               (lambda (c) (/= (length c) 2))
                               "prepare [class name]"
                               (lambda (proxy c)
                                 (process-send-string
                                  proxy
                                  (format "prepare,%s\n" (nth 1 c))))
                               (list jbug-classPrepared-response jbug-error-response jbug-internalException-response))
   (jbug-makeCommandHashEntry "quit"
                               (lambda (c) (/= (length c) 1))
                               "quit"
                               (lambda (proxy c)
                                 (process-send-string
                                  proxy
                                  "quit\n"))
                               (lambda (r) (string= (car r) "proxy")))
   (jbug-makeCommandHashEntry "run"
                               (lambda (c) (/= (length c) 1))
                               "run"
                               (lambda (proxy c)
                                 (process-send-string
                                  proxy
                                  "run\n"))
                               (list jbug-vmResumed-response jbug-error-response jbug-internalException-response))
   (jbug-makeCommandHashEntry "stack"
                               (lambda (c) (or (> (length c) 2)  (and (= (length c) 2)  (not (string-match "[0-9]+" (nth 1 c))))))
                               "stack [thread-id]"
                               (lambda (proxy c)
                                 (process-send-string
                                  proxy
                                  (format
                                   "stack,%s\n"
                                   (if (= (length c) 1) defaultThread (nth 1 c)))))
                               (list jbug-stack-response jbug-error-response jbug-internalException-response))
   (jbug-makeCommandHashEntry "this"
                               (lambda (c) (not (or (= (length c) 1)
                                                    (and (= (length c) 2)  (string-match "[0-9]+" (nth 1 c)))
                                                    (and (= (length c) 3)   (string-match "[0-9]+" (nth 1 c)) (string-match "[0-9]+" (nth 2 c))))))
                               "this [thread-id] [frame number]"
                               (lambda (proxy c)
                                 (process-send-string
                                  proxy
                                  (format
                                   "this,%s,%s\n"
                                   (if (= (length c) 1) defaultThread (nth 1 c))
                                   (if (< (length c) 3) "0" (nth 2 c)))))
                               (lambda (r) (string= (car r) "this")))
   (jbug-makeCommandHashEntry "threads"
                                   (lambda (c) (/= (length c) 1))
                                   "threads"
                                   (lambda (proxy c)
                                     (process-send-string
                                      proxy
                                      "threads\n"))
                               (lambda (r) (string= (car r) "threads"))))))
#+END_SRC

**** Describing a Command About to be Executed

A command about to be executed or being executed is described as a list.

The contents of the list are:

0. the comand key in the hash table commandList
1. the command as it was entered
2. the command as it was entered split on blanks into a list
3. the command as it was sent to the proxy
4. the commands entry in the hash table commandList

#+BEGIN_SRC emacs-lisp :tangle jbug.el
(defun jbug-describeRunnableCommand (key entered split entry)
  (list key entered split entry))

(defun getKeyFromCommandDescription        (cp)  (nth 0 cp))
(defun getEnteredFromCommandDescription  (cp)  (nth 1 cp))
(defun getSplitFromCommandDescription       (cp)  (nth 2 cp))
(defun getCommandHashEntry             (cp)  (nth 3 cp))

#+END_SRC


**** I have a bunch of commands that were just entered by the user

They have been split into a list of strings; each command is a string in the
list.

So what do I do with them?

First I check to see it they make any sense.

The good ones are put into a list of commandDescriptions, the bad ones into a
list of errors. Then we return a list of the two lists.

#+BEGIN_SRC emacs-lisp :tangle jbug.el
(defun jbug-check-commands (cm)
  (let ((checkErrors ())
        (goodCommands ()))
    (dolist (v cm)
      (let* ((c (split-string v " "  't))
             (hashEntry (ht-get commandHashMap (car c))))
        (if (null hashEntry)
            (setq checkErrors (append checkErrors (list (concat "error - no such command: " v))))
          (if (jbug-badCommandP hashEntry c)
              (setq checkErrors (append checkErrors (list (concat "error - bad command format " v ". Try "  (jbug-hashDescribeCommand hashEntry)))))
            (setq goodCommands
                  (-snoc
                   goodCommands
                   (jbug-describeRunnableCommand
                    (jbug-hashKey hashEntry)
                    v
                    c
                    hashEntry)))))))
        (message "jbug-check-commands cm  %s goodCommands %s checkErrors %s" cm goodCommands checkErrors)
    (list goodCommands checkErrors)))

(defun jbug-check-commands-good (ls)  (nth 0 ls))
(defun jbug-check-commands-bad   (ls)  (nth 1 ls))
#+END_SRC

**** Commands Waiting to Run

The commands waiting to run are on a list of CommandDescriptions:

#+BEGIN_SRC emacs-lisp :tangle jbug.el
(defvar commandsToRun  () "list of commands to send to proxy")
#+END_SRC

These commands were entered by the user at some time in the past

We multiple commands entered at a single time as a unit. If one is invalid they
are all invalid.

If all are correct we queue up their descriptions, each waiting for a turn to run.

A command is waiting to run if it is on the commandsToRun list.

A command is sent to the proxy if the commandsToRun list is not empty and if
there is no command in process. So, when we add a command to the commandsToRun
list the precondition of sending a command to the proxy may have been met; we check
by calling jbug-execute-command.

This is how a CommandDescription gets on the list of commands awaiting execution.

#+BEGIN_SRC emacs-lisp :tangle jbug.el
(defun jbug-add-commands (com)
  (let* ((r (jbug-check-commands com))
         (good (jbug-check-commands-good r))
         (bad  (jbug-check-commands-bad r)))
    (if (null bad)
        (setq commandsToRun (append commandsToRun good))
      (dolist (v bad)
        (writeStringToBuffer proxyProcess (concat v "\n")))
      (jbug-fix-output-buffer proxyProcess)))
  (jbug-execute-command))
#+END_SRC

**** What command is the debugger running now?

The command in the variable runningCommand.

#+BEGIN_SRC emacs-lisp :tangle jbug.el
(defvar runningCommand   () "the command which is active in the proxy")

(defun proxyBusy ()    runningCommand)
(defun proxyReady ()  (null runningCommand))
#+END_SRC

**** Sending a Command to the Proxy

Happens in jbug-execute-command.

Two preconditions must be met before a command is sent to the proxy:

1. No command is in process in the proxy,
2. a command is available in the commandsToRun list.

We check the preconditions, and if they are met, execute the command.

All sorts of things are involved in executing a command:

1. the command is put into it's final form, in other words, all defaults get
   added. Note that this is done at the last minute so the defaults might
   have changed from when the command was entered,

2. the command goes into the command history,

3. the command is written to output,

4. the command is sent to the proxy, here is where asynchronouse behavior
   begins.

#+BEGIN_SRC emacs-lisp :tangle jbug.el
(defun jbug-execute-command ()
  (when (and commandsToRun (proxyReady))
    (setq runningCommand (car commandsToRun))
    (setq commandsToRun (cdr commandsToRun))
    (message "jbug-execute-command  runningCommand %s commandsToRun %s" runningCommand commandsToRun)
    (ring-insert jbug-ring (getEnteredFromCommandDescription runningCommand))
    (writeStringToBuffer proxyProcess (concat "\n" commandHeadline (getEnteredFromCommandDescription runningCommand) "\n"))
    (jbug-doCommand
     (getCommandHashEntry runningCommand)
     proxyProcess
     (getSplitFromCommandDescription runningCommand))))
#+END_SRC

**** When Does the Proxy Finish a Command

When one of two things happen:

1. when the proxy signals an error, or
2. when the proxy returns the string described in the CommandDescription.

And, bien sur, if a command is running.

If a command finishes the proxy is ready so run, if available, the next command.

#+BEGIN_SRC emacs-lisp :tangle jbug.el
(defun jbug-checkForCompletedCommand (command)
  (when
      (and runningCommand
           (member command (jbug-hashProxyDoneP (getCommandHashEntry runningCommand))))
    (setq runningCommand ())
    (jbug-execute-command)))
#+END_SRC

*** Handle Responses Received From  the Proxy

Individual commands are handled by functions hung on this hook. The standard
function named jbug-proxy-string-received. See below.

#+BEGIN_SRC emacs-lisp :tangle jbug.el
(defcustom jbug-mode-functions 'jbug-proxy-string-received
  "Abnormal hook run on reception of a string from the proxy."
  :type 'hook
  :options '(jbug-proxy-string-received)
  :group 'jbug)
#+END_SRC

**** Read a Response

The proxy sends data to this elisp program through stdout. That data is
manifested to this program when the following routine runs without warning.

#+BEGIN_SRC emacs-lisp :tangle jbug.el

(setq jbug-receivedFromProxy "")

(defun jbug-insertion-filter (proc string)
  (message "Received: %s :EndReceived" string)
  (setq jbug-receivedFromProxy (concat jbug-receivedFromProxy string))
  (if (s-ends-with? "\n" jbug-receivedFromProxy)
      (let ((com (split-string jbug-receivedFromProxy "\n" 't)))
        (message "jbug-insertion-filter jbug-receivedFromProxy: %s com %s" jbug-receivedFromProxy com)
        (setq jbug-receivedFromProxy "")
        (dolist (c com)
          (if (not (s-blank? c))
              (let* ((response (split-string c ","))
                     (responseHook (ht-get jbug-response-hooks (car response))))
                (if (not responseHook)
                    (message (concat "unknown response " response))
                  (funcall responseHook response)
                  (jbug-fix-output-buffer proc)
                  (jbug-checkForCompletedCommand (car response)))))))))


;;                (run-hook-with-args 'jbug-mode-functions proc (car args) (cdr args))


;; make the output buffer right
(defun jbug-fix-output-buffer (proc)
  (when (and (buffer-live-p (process-buffer proc))
             (get-buffer-window (process-buffer proc)))
    (select-window (get-buffer-window (process-buffer proc)))
    (goto-char (point-max))
    (insert "\n")))

#+END_SRC

And through the magic of hooks, the comma seperated line from the proxy appears
here, probably, as a list of strings.

#+BEGIN_SRC emacs-lisp :tangle jbug.el
(defun jbug-proxy-string-received (proc act args)
  (message "jbug-proxy-string-received act %s args %s runningCommand %s commandsToRun %s" act args runningCommand commandsToRun)
  (cond
   ((string= act "arguments")
    (if
        (or
         (string= (getKeyFromCommandDescription runningCommand) "arguments")
         (string= (getKeyFromCommandDescription runningCommand) "frame"))
        (writeOrgTableToBuffer
         proc
         argumentsTableTitle
         orgTableSeperator
         (if (and args (car args))  (nth 0 (read-from-string (car args)))))))
   ((string= act "breakpoint")
    (let ((second (car args)))
      (cond
       ((string= second "cleared")
        (writeStringToBuffer proc (concat "breakpoint number " (nth 1 args) "cleared.\n")))
       ((string= second "created")
        (writeStringToBuffer proc (concat "breakpoint number " (nth 1 args) " created.\n")))
       ((string= second "entered")
        (reportBreak
         (concat "breakpoint number " (nth 1) " entered ")
         (cdr (member "thread" args))
         (cdr (member "location" args))))
       ((string= second "listed")
        (dolist (v (-split-on "breakpoint" args))
          (writeStringToBuffer proc (concat (s-join " " v) "\n")))))))
   ((string= act "class")
    (let ((second (car args)))
      (cond
       ((string= second "prepared")      (writeStringToBuffer proc (concat "class " (nth 1 args) " loaded.\n")))
       ((string= second "unloaded") (writeStringToBuffer proc (concat "class " (nth 1 args) " unloaded.\n"))))))
   ((string= act "error")
    (writeStringToBuffer proc (concat act " "  (s-join  " " args) "\n")))
   ((string= act "exception")
    (writeStringToBuffer proc (concat "Exception received in proxy: " (car args))))
   ((string= act "frame"))
   ((string= act "locals")
    (if
        (or
         (string= (getKeyFromCommandDescription runningCommand)  "locals")
         (string= (getKeyFromCommandDescription runningCommand) "frame"))
        (writeOrgTableToBuffer
         proc
         localTableTitle
         orgTableSeperator
         (if (and args (car args))  (nth 0 (read-from-string (car args)))))))
   ((string= act "proxy")
    (let ((second (car args)))
      (cond
       ((string= second "exit")
        (delete-process proc)
        (writeStringToBuffer proc "Debugger proxy exited\n"))
       ((string= second "started")
        (writeStringToBuffer proc "Debugger proxy started\n")))))
   ((string= act "stack")
    (writeStringToBuffer proc (concat "thread " (car args) "\n"))
    (dolist (v (-split-on "location" (cdr args)))
      (writeStringToBuffer proc (format "%s:%s %s\n" (nth 0 v) (nth 1 v) (nth 2 v)))))
   ((string= act "step")
    (reportBreak "step"   (cdr (member "thread" args)) (cdr (member "location" args))))
   ((string= act "this")
    (writeOrgTableToBuffer
     proc
     thisTableTitle
     orgTableSeperator
     (if (and args (car args))  (nth 0 (read-from-string (car args))))))
   ((string= act "threads")
    (writeOrgTableToBuffer
         proc
         threadTableTitle
         orgTableSeperator
        (-split-on "thread" args)))
   ((string= act "vm")
    (let ((second (car args)))
      (cond
       ((string= second "created")
        (writeStringToBuffer proc "virtual machine created\n"))
       ((string= second "died")
        (writeStringToBuffer proc "virtual machine terminated\n"))
       ((string= second "disconnected")
        (writeStringToBuffer proc "virtual machine disconnected\n"))
       ((string= second "resuming")
        (writeStringToBuffer proc "virtual machine resuming operation.\n"))
       ((string= second "started")
        (writeStringToBuffer proc "virtual machine started\n")))))
   (t (writeStringToBuffer proc (format "error - unknown response %s arguments %s \n" act (if args args "null"))))))
#+END_SRC


** Input

Input to the elisp program comes from the org buffer created when the mode
starts. The user enters a line at the end of the buffer and types a
newline. That line goes to this elisp program because the mode puts a new
routine for newline into its keymap.

#+BEGIN_SRC emacs-lisp :tangle jbug.el
(defun jbug-newline ()
  (interactive)
  (let ((com (buffer-substring-no-properties
              (line-beginning-position)
              (line-end-position))))
    (if (or
         (/=  (line-end-position) (point-max))
         (not (string-match-p "[a-zA-Z0-9 ]+" com)))
        (org-return)
      (beginning-of-line)
      (ignore-errors (kill-line))  ;; kill-line signals an error at the end of buffer
      (jbug-add-commands (split-string com ";" 't)))))
#+END_SRC

There is a command history.

#+BEGIN_SRC emacs-lisp :noweb-ref create-history
(setq jbug-ring (make-ring 8))
(setq jbug-ring-index 0)
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle jbug.el
  (defun jbug-commandring ()
    (interactive)
    (if (/=  (line-end-position) (point-max))
        (progn
          (goto-char (point-max))
          (insert "\n")
          (setq jbug-ring-index 0))
      (beginning-of-line)
      (ignore-errors (kill-line))  ;; kill-line signals an error at the end of buffer
      (if (not (ring-empty-p jbug-ring))
          (progn
            (if (>= jbug-ring-index (ring-length jbug-ring))
                (setq jbug-ring-index 0))
            (insert (ring-ref jbug-ring jbug-ring-index))
            (setq jbug-ring-index (1+ jbug-ring-index))))))
#+END_SRC

** Output

The debugger outputs its results by writing them to the process buffer created
when it starts.

#+BEGIN_SRC emacs-lisp :tangle jbug.el
  (defconst orgTableSeperator    "|----|\n"                                                               "string to seperate table title from contents")
  (defconst localTableTitle         "|Locals|\n"                                                          "title for local variables table")
  (defconst argumentsTableTitle  "|Arguments|\n"                                                    "title for method arguments table")
  (defconst threadTableTitle       "|ID|Name|State|Frames|Breakpoint|Suspended|\n"     "title for thread table")
  (defconst thisTableTitle          "|This|\n"                                                              "title for this table")

  (defconst sessionHeadline     "* "     "start of debugging session")
  (defconst breakpointHeadline "** "    "reports a breakpoint")
  (defconst commandHeadline  "*** "   "enter a command")
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle jbug.el
  (defun writeStringToBuffer (proc string)
    (when (buffer-live-p (process-buffer proc))
      (with-current-buffer (process-buffer proc)
        (save-excursion
          ;; Insert the text, advancing the process marker.
          (goto-char (point-max))
          (insert string)))))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle jbug.el
  (defun writeOrgTableToBuffer (proc title sep rows)
    (when (buffer-live-p (process-buffer proc))
      (with-current-buffer (process-buffer proc)
        (save-excursion
          ;; Insert the text, advancing the process marker.
          (goto-char (point-max))
          (insert (concat "\n\n" title))
          (let ((tableStart (point)))
            (insert sep)
            (insert (dataLayout rows))
            (goto-char tableStart)
            (ignore-errors (org-ctrl-c-ctrl-c)))))))

  (defun dataLayout (args)
    (if args
        (let ((s "| ")
              (stack ())
              (rc 0)
              (ac 0))
          (push (list rc args) stack)
          (while stack
            (cond
             ((not args)
              (let ((a (pop stack)))
                (setq args (nth 1 a))
                (setq rc     (nth 0 a))))
             ((listp (car args))
              (push (list rc (cdr args)) stack)
              (setq args (car args)))
             ((not (listp (car args)))
              (let ((v (car args)))
                (setq args (cdr args))
                (while (/= rc ac)
                  (cond
                   ((< ac rc)
                    (setq s (concat s " | "))
                    (setq ac (1+ ac)))
                   ((> ac rc)
                    (setq s (concat s "\n| "))
                    (setq ac 0))))
                (setq s (concat s v))
                (setq rc (1+ rc))))))
          s)
      ""))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle jbug.el
(defun reportBreak (preface thread location)
  (setq defaultThread (threadID thread))
  (writeStringToBuffer
   proc
   (concat
    breakpointHeadline
    preface
    " in thread "
    (threadID thread)
    " at "
    (locationFile location)
    ":"
    (locationLineNumber location)
    "\n"))
  (setSourceFileWindow
   proc
   (locationFile location)
   (locationLineNumber location)))

(defun threadID               (args) (nth 0 args))
(defun threadName          (args) (nth 1 args))
(defun threadState           (args) (nth 2 args))
(defun threadFrames       (args) (nth 3 args))
(defun threadBreakpoint  (args) (nth 4 args))
(defun threadSuspended (args) (nth 5 args))

(defun locationFile             (args) (nth 0 args))
(defun locationLineNumber (args) (nth 1 args))
(defun locationMethod        (args) (nth 2 args))

#+END_SRC

*** Set windows

We would really like two windows. One with the source file in it, the cursor on
the current line, a bookmark on that line, and that line in the middle of the
window. The other showing the org file with the cursor on the last line. Maybe
we can get this, maybe not.

#+BEGIN_SRC emacs-lisp :tangle jbug.el
(defun setSourceFileWindow (proc file line)
  (let ((bug (find-file-noselect file)))
    (when (and bug (buffer-live-p (process-buffer proc)))
      (if (= (length (window-list)) 1)
          (split-window))
      (let ((source (winForOtherBuffer bug (process-buffer proc))))
        (if source
            (select-window source)
          (set-buffer bug))
        (goto-char (point-min))
        (forward-line (1- (string-to-number line)))
        (bm-remove-all-all-buffers)
        (bm-toggle)
        (if (eq (window-buffer) bug) (recenter-top-bottom)))
      (let ((procWin (winForOtherBuffer (process-buffer proc) bug)))
        (if procWin
            (select-window procWin)
          (set-buffer (process-buffer proc)))
        (goto-char (point-max))))))

(defun winForOtherBuffer (buffer notbuffer)
  (let ((win (get-buffer-window buffer)))
    (when (not win)
      (let  ((wl (window-list)))
        (while (and wl (eq notbuffer (window-buffer (car wl))))
          (setq wl (cdr wl)))
        (setq win (if wl (car wl) (car (window-list))))
        (set-window-buffer win buffer)))
    win))
#+END_SRC

** OK, start her up

#+BEGIN_SRC emacs-lisp :noweb tangle :tangle jbug.el

(defun jbugMode  (src mn host port)
    (interactive "Droot of source tree: \nMmain class: \nMhost: \nMport number: ")
    (message "startProc")
    (find-file (concat mn (format-time-string ".%Y,%m.%d.%H.%M.%S") ".org"))
    (insert "#+STARTUP: showeverything\n")
    (goto-char (point-max))
    (insert
     (concat
      "\n\n" sessionHeadline
      "Starting debugger session " (current-time-string)
      ".\n\tSource directory: " src
      ".\n\tMain class: " mn
      ".\n\tHost: " host
      ".\n\tPort: "  port ".\n\n"));
    (delete-other-windows)
    (jbug-mode)
    (add-hook 'jbug-mode-functions 'jbug-proxy-string-received)

    ;; set up the command history

    <<create-history>>

    ;; start the proxy

    <<start-proxy>>

    (goto-char (point-max))
    (set-marker (process-mark proxyProcess) (point))
    (insert (format "attach %s %s;prepare %s;load;break %s main;continue" host port mn mn))
    (jbug-newline))
#+END_SRC
