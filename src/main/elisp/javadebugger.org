* Java Debugger

** javadebug mode

#+BEGIN_SRC emacs-lisp :tangle bugged.el

(require 'bm)
(require 'dash)
(require 'ht)
(require 's)

(defvar javadebug-mode-map
  (let ((map (make-sparse-keymap)))
    (define-key map (kbd "RET") 'javadebug-newline)
    (define-key map (kbd "M-p") 'javadebug-previous-command-in-history)
    (define-key map (kbd "M-n") 'javadebug-next-command-in-history)
    map))

(define-derived-mode javadebug-mode
  org-mode "JavaDebug"
  "Major mode java debugger.")

(defvar defaultThread "1" "the last thread in which we had a breakpoint. use this thread if no thread number is specified in a command")
(defvar defaultFrame  0   "the frame we examined")

#+END_SRC

** The Proxy

There is a JAVA prgram called the 'proxy' which connects to the target process
and handles the JDI interface.  The proxy runs as a sub process to emacs. This
elisp program sends commands to the proxy on stdin and receives replies on
stdout.

#+BEGIN_SRC emacs-lisp :tangle bugged.el
(defvar proxyProcess () "the JAVA proxy program which connects to the program to be debugged")

(defcustom javadebugger-proxy
  "java -cp ~/javadebugger/src/main/java/com/github/jruby21/javadebugger/JavaDebuggerProxy:~/jdk1.8.0_131/lib/tools.jar com.github.jruby21.javadebugger.JavaDebuggerProxy"
  "full command to run javadebugger proxy"
  :type '(string)
  :group 'javadebugger)
#+END_SRC

*** Start the proxy

Start the proxy and set the filter which handles strings received on stdin from
the proxy.  There is a special debugger command (proxy) that does nothing but
wait for the proxy to signal that it has started.

#+BEGIN_SRC emacs-lisp :noweb-ref start-proxy

(setq commandsToRun ())

(setq runningCommand
      (javadebug-describeRunnableCommand
       "proxy"
       "proxy"
       (list "proxy")
       (javadebug-makeCommandHashEntry
        "proxy"
        (lambda (c) ())
        ""
        (lambda (c) "")
        (list javadebugger-proxyStarted-response))))

(setq proxyProcess (apply 'start-process "javadebuggerProxy"  (current-buffer) (split-string javadebugger-proxy)))
(set-process-filter proxyProcess 'javadebug-insertion-filter)

#+END_SRC


#+BEGIN_SRC emacs-lisp :tangle bugged.el

(setq javadebug-response-functions (ht-create))

#+END_SRC

** Debugger Commands

These are the commands a user can enter to the debugger.

Each command is described by a CommandHashEntry. Notice that we are doing low
rent object oriented programming describing each command with a list containing
methods for that command.

The commands are kept in a hash table called commandHashMap. The table is
indexed by the string a user enters to invoke a command. The value for a key is
a CommandHashEntry.  When the user types a command, the command is looked up in
the hash table.

#+BEGIN_SRC emacs-lisp :tangle bugged.el
(defun javadebug-makeCommandHashEntry (hashKey badCommandP describeCommand executeCommand proxyDoneP)
  (list hashKey badCommandP describeCommand executeCommand proxyDoneP))

(defun javadebug-hashKey                (hashEntry) (nth 0 hashEntry))
(defun javadebug-hashBadCommandP        (hashEntry) (nth 1 hashEntry))
(defun javadebug-hashDescribeCommand    (hashEntry) (nth 2 hashEntry))
(defun javadebug-hashDoCommand          (hashEntry) (nth 3 hashEntry))
(defun javadebug-hashProxyDoneP         (hashEntry) (nth 4 hashEntry))

(defun javadebug-badCommandP    (e f)   (funcall (javadebug-hashBadCommandP e) f))
(defun javadebug-checkProxyDone (e f)   (funcall (javadebug-hashProxyDoneP e)  f))
(defun javadebug-doCommand      (e p f) (funcall (javadebug-hashDoCommand e)   p f))

(defconst commandHashMap (ht-create))

#+END_SRC

The commandHashMap is filled with commands below.

*** Input a command

Input to the elisp program comes from the org buffer created when the mode
starts. The user enters a line at the end of the buffer and types a
newline. That line goes to this elisp program because the mode puts a new
routine for newline into its keymap.

If the line is entered at the very bottom of the buffer it is treated as a
command. Otherwise, it is just an ordinary line in a ORG buffer.

Multiple commands can be entered if they are seperated by a semicolon. Each
individual command is a series of tokens seperated by blanks. The first token
identifies the command.

#+BEGIN_SRC emacs-lisp :tangle bugged.el
(defun javadebug-newline ()
  (interactive)
  (let ((com (buffer-substring-no-properties
              (line-beginning-position)
              (line-end-position))))
    (if (or
         (/=  (line-end-position) (point-max))
         (not (string-match-p "[a-zA-Z0-9 ]+" com)))
        (org-return)
      (setq javadebug-point-in-history 0)
      (beginning-of-line)
      (ignore-errors (kill-line))  ;; kill-line signals an error at the end of buffer
      (javadebug-add-commands (split-string com ";" 't)))))
#+END_SRC

There is a command history.

#+BEGIN_SRC emacs-lisp  :tangle bugged.el

(defvar javadebug-point-in-history 1 "pointing to the current position in command history")

(defun javadebug-get-old-command (count)
  (save-excursion
    (goto-char (point-max))

    (while
        (and
         (> count 0)
         (outline-previous-heading))
      (if
          (and
           (outline-on-heading-p 't)
           (= (- (match-end 0) (match-beginning 0) 1) 3))
          (setq count (1- count))))

    (if
        (and
         (= count 0)
         (outline-on-heading-p 't)
         (= (- (match-end 0) (match-beginning 0) 1) 3))
        (s-trim
         (buffer-substring-no-properties (match-end 0) (progn (end-of-line) (point))))
      ())))

(defun javadebug-previous-command-in-history ()
  (interactive)
  (goto-char (point-max))
  (let ((command (javadebug-get-old-command (1+ javadebug-point-in-history))))
    (when
        command
      (javadebug-position-old-command command)
      (setq javadebug-point-in-history (1+ javadebug-point-in-history)))))

(defun javadebug-next-command-in-history ()
  (interactive)
  (goto-char (point-max))
  (when
      (> javadebug-point-in-history 1)
    (let ((command (javadebug-get-old-command (1- javadebug-point-in-history))))
      (when
          command
        (javadebug-position-old-command command)
        (setq javadebug-point-in-history (1- javadebug-point-in-history))))))

(defun javadebug-position-old-command (command)
  (goto-char (point-max))
  (beginning-of-line)
  (ignore-errors (kill-line))  ;; kill-line signals an error at the end of buffer
  (insert command))

#+END_SRC

This is the code which runs when the user enters a command. A lot of the work is
done by the javadebug-check-commands routine which goes through the list of
commands, looks each one up in the commandHashMap, checks the entered string
with the routine kept in the javadebug-hashBadCommandP entry in the command's
CommandHashEntry, puts all the good commands in one list, the bad commands in
another, and returns the two lists. If there are any errors, they are printed
out. If all the commands are good, they are queued for execution by being added
to the commandsToRun list. At the end we run javadebug-execute-command which may
send a command to the proxy.

#+BEGIN_SRC emacs-lisp :tangle bugged.el

(defvar commandsToRun  () "list of commands to send to proxy")

(defun javadebug-add-commands (com)
  (let* ((r (javadebug-check-commands com))
         (good (javadebug-check-commands-good r))
         (bad  (javadebug-check-commands-bad r)))
    (if (null bad)
        (setq commandsToRun (append commandsToRun good))
      (dolist (v bad)
        (writeStringToBuffer proxyProcess (concat v "\n")))
      (javadebug-fix-output-buffer proxyProcess)))
  (javadebug-execute-command))

(defun javadebug-check-commands (cm)
  (let ((checkErrors ())
        (goodCommands ()))
    (dolist (v cm)
      (let* ((c (split-string v " "  't))
             (hashEntry (ht-get commandHashMap (car c))))
        (if (null hashEntry)
            (setq checkErrors (append checkErrors (list (concat "error - no such command: " v))))
          (if (javadebug-badCommandP hashEntry c)
              (setq checkErrors (append checkErrors (list (concat "error - bad command format " v ". Try "  (javadebug-hashDescribeCommand hashEntry)))))
            (setq goodCommands
                  (-snoc
                   goodCommands
                   (javadebug-describeRunnableCommand
                    (javadebug-hashKey hashEntry)
                    v
                    c
                    hashEntry)))))))
        (message "javadebug-check-commands cm  %s goodCommands %s checkErrors %s" cm goodCommands checkErrors)
    (list goodCommands checkErrors)))

(defun javadebug-check-commands-good (ls)  (nth 0 ls))
(defun javadebug-check-commands-bad   (ls)  (nth 1 ls))

#+END_SRC

*** Describing a Command About to be Executed

What exactly gets put on the commandsToRun queue?

Another list pretending to be an object. This list was created in
javadebug-check-commands.

The contents of the list are:

0. the comand key in the hash table commandList
1. the command as it was entered
2. the command as it was entered split on blanks into a list
3. the command's entry in the hash table commandHashMap.

An entry in the list is created by the javadebug-describeRunnableCommand.

#+BEGIN_SRC emacs-lisp :tangle bugged.el
(defun javadebug-describeRunnableCommand (key entered split entry)
  (list key entered split entry))

(defun getKeyFromCommandDescription        (cp)  (nth 0 cp))
(defun getEnteredFromCommandDescription  (cp)  (nth 1 cp))
(defun getSplitFromCommandDescription       (cp)  (nth 2 cp))
(defun getCommandHashEntry             (cp)  (nth 3 cp))

#+END_SRC

*** Run a command

Commands run one at a time, that is, a new command is not started until the
previous command has finished. The command which is currently running is kept in
the variable runningCommand (more exactly, the list create by
describeRunnableCommand for that command is kept in runningCommand).

#+BEGIN_SRC emacs-lisp :tangle bugged.el
(defvar runningCommand   () "the command which is active in the proxy")

(defun proxyBusy ()    runningCommand)
(defun proxyReady ()  (null runningCommand))
#+END_SRC

A command finishes when the proxy returns a response for which it is
waiting. The appropriate responses are contained in the command's
commandHashEntry. Usually that list includes an error response and the internal
interrupt response. When we receive a response from the proxy, we check the
response against the running commands expected responses. If they match, the
running command has finished so we set runningCommand to null and try to start a
new command. All this happens in the routine javadebug-checkForCompletedCommand.

#+BEGIN_SRC emacs-lisp :tangle bugged.el
(defun javadebug-checkForCompletedCommand (response)
  (when
      (and runningCommand
           (member response (javadebug-hashProxyDoneP (getCommandHashEntry runningCommand))))
    (setq runningCommand ())
    (javadebug-execute-command)))
#+END_SRC

The command synchronisation mechanism is pretty simple.

Two preconditions must be met before a command is sent to the proxy:

1. No command is in process in the proxy (runningCommand is null),
2. a command is available in the commandsToRun list (commandsToRun is not null).

Whenever one of those preconditions changes we call javadebug-execute-command
which checks both. If both hold, we run the command.

All sorts of things are involved in executing a command:

1. the command is put into it's final form, in other words, all defaults get
   added. Note that this is done at the last minute so the defaults might
   have changed from when the command was entered. The work is done
   by a method contained in the command's hashMapEntry which is an
   entry in the list created by javadebug-describeRunnableCommand which
   list is the element we took off the front of commandsToRun and placed into
   runningCommand.

2. the command (as an ascii string) goes into the command history,

3. the command is written to output,

4. the command is placed in runningCommand,

5. we run the function contained in the doCommand field of the command's
   commandHashEntry. This usually sends the command to the proxy.

#+BEGIN_SRC emacs-lisp :tangle bugged.el
(defun javadebug-execute-command ()
  (when (and commandsToRun (proxyReady))
    (setq runningCommand (car commandsToRun))
    (setq commandsToRun (cdr commandsToRun))
    (message "javadebug-execute-command  runningCommand %s commandsToRun %s" runningCommand commandsToRun)
    (writeStringToBuffer proxyProcess (concat "\n" commandHeadline (getEnteredFromCommandDescription runningCommand) "\n"))
    (javadebug-doCommand
     (getCommandHashEntry runningCommand)
     proxyProcess
     (getSplitFromCommandDescription runningCommand))))
#+END_SRC

Now we wait for the command to finish or for the user to act.

** Responses from the proxy

The proxy sends message to this elisp program by writing them to its
stdout. EMACS receives the messages on stdin and passes them to this elisp
program by calling the insertion filter defined below.

*** Responses

There is a set of possible responses (or commands if you like) that can be
received from the proxy. A response is a new line terminated ascii string. Each
string is a set of comma seperated values. The first value identifies the
response. Each possible first value is defined as a constant and used as a key
for an entry in the javadebug-response-functions hash table.

#+BEGIN_SRC emacs-lisp :tangle bugged.el
(setq javadebug-response-functions (ht-create))
#+END_SRC

For each entry in the table (and so for each response) we create an emacs hook
variable. The value in the javadebug-response-functions table is a function which
parses the response and calls the functions which were added to the hook. The
idea being that a user can customize the debugger by adding his own functions to
a response's hook.

Here is an example of a response definition. This code runs when a proxy returns
a list of running threads in response to a "threads" command.

#+BEGIN_EXAMPLE

(defconst javadebugger-threadList-response "threadlist" "")
(defvar javadebugger-threadList-functions nil)
(setq javadebugger-threadList-functions ())
(ht-set javadebug-response-functions
   javadebugger-threadList-response
   (lambda (response)
       (run-hook-with-args 'javadebugger-threadList-functions
          (-partition-in-steps 6 6 (-slice response 1)))))

(add-hook 'javadebugger-threadList-functions
          (lambda (threads)
            (writeOrgTableToBuffer
             proxyProcess
             threadTableTitle
             orgTableSeperator
             threads)))
#+END_EXAMPLE

Responses are defined below.

*** Receive a Response

The proxy sends data to this elisp program through stdout. That data is
manifested to this program when EMACS calls the following routine without
warning. The routine can return a response in pieces so we have to buffer
the string returned. A response is ended by a new line.

When we get a response, we split it on the commas and use the first field to
look up the response's entry in the javadebug-response-functions hash map. If the
entry exists, it is a function which we execute with a funcall, knowing all
along that the function will execute the hooks for this response. Then we clean
up the output buffer and call javadebug-checkForCompletedCommand since the
runningCommand may have finished and it might be time to start another command.

#+BEGIN_SRC emacs-lisp :tangle bugged.el

(setq javadebugger-receivedFromProxy "")

(defun javadebug-insertion-filter (proc string)
  (message "Received: %s :EndReceived" string)
  (setq javadebugger-receivedFromProxy (concat javadebugger-receivedFromProxy string))
  (if (s-ends-with? "\n" javadebugger-receivedFromProxy)
      (let ((com (split-string javadebugger-receivedFromProxy "\n" 't)))
        (message "javadebug-insertion-filter javadebugger-receivedFromProxy: %s com %s" javadebugger-receivedFromProxy com)
        (setq javadebugger-receivedFromProxy "")
        (dolist (c com)
          (if (not (s-blank? c))
              (let* ((response (mapcar 's-trim (split-string c ",")))
                     (responseHook (ht-get javadebug-response-functions (car response))))
                (if (not responseHook)
                    (message (concat "unknown response " response))
                  ;; well, who knows what came back
                  (condition-case err
                      (funcall responseHook response)
                    (error
                     (progn
                       (setq runningCommand ())
                       (message "Error in a response hook %s"  (error-message-string err)))))
                  (javadebug-fix-output-buffer proc)
                  (javadebug-checkForCompletedCommand (car response)))))))))

;; make the output buffer right
(defun javadebug-fix-output-buffer (proc)
  (when (and (buffer-live-p (process-buffer proc))
             (get-buffer-window (process-buffer proc)))
    (select-window (get-buffer-window (process-buffer proc)))
    (goto-char (point-max))
    (insert "\n")))
#+END_SRC

** Output

The debugger outputs its results by writing them to the process buffer created
when it started. The buffer is an ORG mode buffer.

#+BEGIN_SRC emacs-lisp :tangle bugged.el
  (defconst orgTableSeperator    "|----|\n"                                                               "string to seperate table title from contents")
  (defconst localTableTitle         "|Locals|\n"                                                          "title for local variables table")
  (defconst argumentsTableTitle  "|Arguments|\n"                                                    "title for method arguments table")
  (defconst threadTableTitle       "|ID|Name|State|Frames|Breakpoint|Suspended|\n"     "title for thread table")
  (defconst thisTableTitle          "|This|\n"                                                              "title for this table")

  (defconst sessionHeadline     "* "     "start of debugging session")
  (defconst breakpointHeadline "** "    "reports a breakpoint")
  (defconst commandHeadline  "*** "   "enter a command")
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle bugged.el
  (defun writeStringToBuffer (proc string)
    (when (buffer-live-p (process-buffer proc))
      (with-current-buffer (process-buffer proc)
        (save-excursion
          ;; Insert the text, advancing the process marker.
          (goto-char (point-max))
          (insert string)))))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle bugged.el
  (defun writeOrgTableToBuffer (proc title sep rows)
    (when (buffer-live-p (process-buffer proc))
      (with-current-buffer (process-buffer proc)
        (save-excursion
          ;; Insert the text, advancing the process marker.
          (goto-char (point-max))
          (insert (concat "\n\n" title))
          (let ((tableStart (point)))
            (insert sep)
            (insert (dataLayout rows))
            (goto-char tableStart)
            (ignore-errors (org-ctrl-c-ctrl-c)))))))

  (defun dataLayout (args)
    (if args
        (let ((s "| ")
              (stack ())
              (rc 0)
              (ac 0))
          (push (list rc args) stack)
          (while stack
            (cond
             ((not args)
              (let ((a (pop stack)))
                (setq args (nth 1 a))
                (setq rc     (nth 0 a))))
             ((listp (car args))
              (push (list rc (cdr args)) stack)
              (setq args (car args)))
             ((not (listp (car args)))
              (let ((v (car args)))
                (setq args (cdr args))
                (while (/= rc ac)
                  (cond
                   ((< ac rc)
                    (setq s (concat s " | "))
                    (setq ac (1+ ac)))
                   ((> ac rc)
                    (setq s (concat s "\n| "))
                    (setq ac 0))))
                (setq s (concat s v))
                (setq rc (1+ rc))))))
          s)
      ""))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle bugged.el
(defun reportBreak (preface thread location)
  (setq defaultThread (threadID thread))
  (setq defaultFrame 0)
  (writeStringToBuffer
   proc
   (concat
    breakpointHeadline
    preface
    " in thread "
    (threadID thread)
    " at "
    (locationFile location)
    ":"
    (locationLineNumber location)
    "\n"))
  (setSourceFileWindow
   proc
   (locationFile location)
   (locationLineNumber location)))

(defun threadID               (args) (nth 0 args))
(defun threadName          (args) (nth 1 args))
(defun threadState           (args) (nth 2 args))
(defun threadFrames       (args) (nth 3 args))
(defun threadBreakpoint  (args) (nth 4 args))
(defun threadSuspended (args) (nth 5 args))

(defun locationFile             (args) (nth 0 args))
(defun locationLineNumber (args) (nth 1 args))
(defun locationMethod        (args) (nth 2 args))

#+END_SRC

*** Set windows

We would really like two windows. One with the source file in it, the cursor on
the current line, a bookmark on that line, and that line in the middle of the
window. The other showing the org file with the cursor on the last line. Maybe
we can get this, maybe not.

#+BEGIN_SRC emacs-lisp :tangle bugged.el
(defun setSourceFileWindow (proc file line)
(message (format "setsourcewindow %s | %s | %s\n" sourceDirectory file (concat sourceDirectory file)))
  (let ((bug (find-file-noselect (concat sourceDirectory file))))
    (when (and bug (buffer-live-p (process-buffer proc)))
      (if (= (length (window-list)) 1)
          (split-window))
      (let ((source (winForOtherBuffer bug (process-buffer proc))))
        (if source
            (select-window source)
          (set-buffer bug))
        (goto-char (point-min))
        (forward-line (1- (string-to-number line)))
        (bm-remove-all-all-buffers)
        (bm-toggle)
        (if (eq (window-buffer) bug) (recenter-top-bottom)))
      (let ((procWin (winForOtherBuffer (process-buffer proc) bug)))
        (if procWin
            (select-window procWin)
          (set-buffer (process-buffer proc)))
        (goto-char (point-max))))))

(defun winForOtherBuffer (buffer notbuffer)
  (let ((win (get-buffer-window buffer)))
    (when (not win)
      (let  ((wl (window-list)))
        (while (and wl (eq notbuffer (window-buffer (car wl))))
          (setq wl (cdr wl)))
        (setq win (if wl (car wl) (car (window-list))))
        (set-window-buffer win buffer)))
    win))
#+END_SRC

** Start up

#+BEGIN_SRC emacs-lisp :noweb tangle :tangle bugged.el

(defvar sourceDirectory nil "Root directory of the sources for the target JAVA program")

(defun javadebugMode  (src mn host port)
    (interactive "Droot of source tree: \nMmain class: \nMhost: \nMport number: ")
    (message "startProc")
    (find-file (concat mn (format-time-string ".%Y,%m.%d.%H.%M.%S") ".org"))
    (insert "#+STARTUP: showeverything\n")
    (goto-char (point-max))
    (setq sourceDirectory (file-name-as-directory (expand-file-name src)))
    (insert
     (concat
      "\n\n" sessionHeadline
      "Starting debugger session " (current-time-string)
      ".\n\tSource directory: " sourceDirectory
      ".\n\tMain class: " mn
      ".\n\tHost: " host
      ".\n\tPort: "  port ".\n\n"));
    (delete-other-windows)
    (javadebug-mode)

    ;; start the proxy

    <<start-proxy>>

    (goto-char (point-max))
    (set-marker (process-mark proxyProcess) (point))
    (insert (format "attach %s %s;prepare %s;wait classprepared;break %s main;catch on;continue" host port mn mn))
    (javadebug-newline))
#+END_SRC

** Commands and responses

#+BEGIN_SRC emacs-lisp :tangle bugged.el#+BEGIN_SRC emacs-lisp :tangle bugged.el
(defconst javadebugger-accessWatchpointSet-response "accesswatchpointset" "")
(defconst javadebugger-arguments-response "arguments" "")
(defconst javadebugger-breakpointCleared-response "breakpointcleared" "")
(defconst javadebugger-breakpointCreated-response "breakpointcreated" "")
(defconst javadebugger-breakpointEntered-response "breakpointentered" "")
(defconst javadebugger-breakpointList-response "breakpointlist" "")
(defconst javadebugger-catchEnabled-response "catchenabled" "")
(defconst javadebugger-classPrepared-response "classprepared" "")
(defconst javadebugger-classUnloaded-response "classunloaded" "")
(defconst javadebugger-classes-response "classes" "")
(defconst javadebugger-error-response "error" "")
(defconst javadebugger-exception-response "exception" "")
(defconst javadebugger-fields-response "fields" "")
(defconst javadebugger-internalException-response "internalexception" "")
(defconst javadebugger-locals-response "locals" "")
(defconst javadebugger-log-response "log" "")
(defconst javadebugger-modificationWatchpoint-response "modificationwatchpoint" "")
(defconst javadebugger-modificationWatchpointSet-response "modificationwatchpointset" "")
(defconst javadebugger-preparingClass-response "preparingclass" "")
(defconst javadebugger-proxyExited-response "proxyexited" "")
(defconst javadebugger-proxyStarted-response "proxystarted" "")
(defconst javadebugger-stack-response "stack" "")
(defconst javadebugger-step-response "step" "")
(defconst javadebugger-stepCreated-response "stepcreated" "")
(defconst javadebugger-this-response "this" "")
(defconst javadebugger-threadDied-response "threaddied" "")
(defconst javadebugger-threadList-response "threadlist" "")
(defconst javadebugger-threadStarted-response "threadstarted" "")
(defconst javadebugger-vmCreated-response "vmcreated" "")
(defconst javadebugger-vmDied-response "vmdied" "")
(defconst javadebugger-vmDisconnected-response "vmdisconnected" "")
(defconst javadebugger-vmResumed-response "vmresumed" "")
(defconst javadebugger-vmStarted-response "vmstarted" "")
#+END_SRC

**** access

Set an access watchpoint.

Request for notification when the contents of a field are accessed in the target
VM. This event will be triggered when the specified field is accessed by Java
programming language code or by a Java Native Interface (JNI) get function.

#+BEGIN_SRC emacs-lisp :tangle bugged.el

(ht-set
 commandHashMap
 "access"
 (javadebug-makeCommandHashEntry
  "access"
  (lambda (c) (/= (length c) 3))
  "access class-name field-name"
  (lambda (proxy c)
    (process-send-string
     proxy
     (format
      "access,%s,%s\n"
      (nth 1 c)
      (nth 2 c))))
  (list javadebugger-accessWatchpointSet-response javadebugger-error-response javadebugger-internalException-response javadebugger-exception-response)))

(defconst  javadebugger-accessWatchpointSet-response  "accesswatchpointset" "")
(defvar javadebugger-accessWatchpointSet-functions nil)
(setq javadebugger-accessWatchpointSet-functions ())

(ht-set
 javadebug-response-functions
 'javadebugger-accessWatchpointSet-response
 (lambda (response)
   (run-hooks 'javadebugger-accessWatchpointSet-functions )))

(add-hook
 'javadebugger-accessWatchpointSet-functions (lambda ()
                                          (writeStringToBuffer proc (concat "Access watchpoint set.\n"))))


(defconst
  javadebugger-accessWatchpoint-response
  "accesswatchpoint" "")

(defvar javadebugger-accessWatchpoint-functions nil)
(setq javadebugger-accessWatchpoint-functions ())

(ht-set javadebug-response-functions
        javadebugger-accessWatchpoint-response
        (lambda (response)
          (run-hook-with-args 'javadebugger-accessWatchpoint-functions
                              (nth 1 response)
                              (nth 2 response)
                              (nth 0 (read-from-string (nth 3 response))))))

(add-hook 'javadebugger-accessWatchpoint-functions
          (lambda (className fieldName value)
            (writeStringToBuffer proxyProcess  "Access watchpoint\n")
            (writeOrgTableToBuffer
             proxyProcess
             "|Class:Field|Value|\n"
             orgTableSeperator
             (list (concat className ":" fieldName) value))))



#+END_SRC

**** arguments

Print the arguments to a method.

By default prints all local variables but can specify the variables to print
with a variable descriptor string.

#+BEGIN_SRC emacs-lisp :tangle bugged.el

(ht-set
 commandHashMap
 "arguments"
 (javadebug-makeCommandHashEntry
  "arguments"
  (lambda (c) (and (/= (length c) 1) (/= (length c) 2)))
  "arguments [variable names]"
  (lambda (proxy c)
    (process-send-string
     proxy
     (format
      "arguments,%s,%s,%s\n"
      defaultThread
      (number-to-string defaultFrame)
      (if (= (length c) 2) (nth 1 c) "*"))))
  (list javadebugger-arguments-response javadebugger-error-response javadebugger-internalException-response javadebugger-exception-response)))

(defvar javadebugger-arguments-functions nil)
(setq   javadebugger-arguments-functions ())

(ht-set
 javadebug-response-functions
 javadebugger-arguments-response
 (lambda (response)
   (run-hook-with-args
    'javadebugger-arguments-functions
    (nth 1 response)
    (nth 2 response)
    (nth 0 (read-from-string (nth 3 response))))))

(add-hook
 'javadebugger-arguments-functions
 (lambda (thread frame th)
   (writeStringToBuffer
    proxyProcess
    (format "Arguments for thread %s frame number %s.\n" thread frame))
   (writeOrgTableToBuffer
    proxyProcess
    "| Name | Value |\n"
    orgTableSeperator
    th)))

#+END_SRC

**** attach

Attach the debugger to the target VM.

#+BEGIN_SRC emacs-lisp :tangle bugged.el

(ht-set
 commandHashMap
 "attach"
   (javadebug-makeCommandHashEntry "attach"
                               (lambda (c) (or (/= (length c) 3)  (not (string-match "[0-9]+" (nth 2 c)))))
                               "attach host  [port number ]"
                               (lambda (proxy c)
                                 (process-send-string
                                  proxy
                                  (format "attach,%s,%s\n" (nth 1 c) (nth 2 c))))
                               (list javadebugger-vmStarted-response  javadebugger-error-response javadebugger-internalException-response javadebugger-exception-response)))

(defvar javadebugger-vmCreated-functions nil)
(setq javadebugger-vmCreated-functions ())
(ht-set javadebug-response-functions
   javadebugger-vmCreated-response
   (lambda (response) (run-hooks 'javadebugger-vmCreated-functions )))

(add-hook 'javadebugger-vmCreated-functions (lambda ()
        (writeStringToBuffer proxyProcess "virtual machine created\n")))

(defconst javadebugger-vmStarted-response "vmstarted" "")
(defvar javadebugger-vmStarted-functions nil)
(setq javadebugger-vmStarted-functions ())
(ht-set javadebug-response-functions
   javadebugger-vmStarted-response
   (lambda (response) (run-hooks 'javadebugger-vmStarted-functions )))

(add-hook 'javadebugger-vmStarted-functions (lambda ()
              (writeStringToBuffer proxyProcess "virtual machine started\n")))

#+END_SRC

**** break

Set a breakpoint in the target VM.

#+BEGIN_SRC emacs-lisp :tangle bugged.el

(ht-set
 commandHashMap
 "break"
   (javadebug-makeCommandHashEntry "break"
                               (lambda (c) (/= (length c) 3))
                               "break class-name <line-number|method name>"
                               (lambda (proxy c)
                                 (process-send-string
                                  proxy
                                  (format "break,%s,%s\n" (nth 1 c) (nth 2 c))))
                               (list javadebugger-breakpointCreated-response javadebugger-error-response javadebugger-internalException-response javadebugger-exception-response)))

(defvar javadebugger-breakpointCreated-functions nil)
(setq javadebugger-breakpointCreated-functions ())
(ht-set javadebug-response-functions
   javadebugger-breakpointCreated-response
   (lambda (response) (run-hook-with-args 'javadebugger-breakpointCreated-functions (nth 1 response) (-slice response 2 5))))

(add-hook 'javadebugger-breakpointCreated-functions
          (lambda ( breakId loc)
            (writeStringToBuffer proc (concat "Breakpoint  " breakId " created at " (javadebugger-LocationString loc)  ".\n"))))

(defvar javadebugger-breakpointEntered-functions nil)
(setq javadebugger-breakpointEntered-functions ())
(ht-set javadebug-response-functions
   javadebugger-breakpointEntered-response
   (lambda (response) (run-hook-with-args 'javadebugger-breakpointEntered-functions (nth 1 response) (-slice response 2 8) (-slice response 8))))

(add-hook 'javadebugger-breakpointEntered-functions
          (lambda ( breakId tr loc)
            (reportBreak (concat "Breakpoint " breakId " entered") tr loc)))

#+END_SRC

**** breaks

List breakpoints enabled in the target VM.

#+BEGIN_SRC emacs-lisp :tangle bugged.el

(ht-set
 commandHashMap
 "breaks"
   (javadebug-makeCommandHashEntry "breaks"
                                   (lambda (c) (/= (length c) 1))
                                   "breaks"
                                   (lambda (proxy c)
                                     (process-send-string
                                      proxy
                                      "breaks\n"))
                               (list
                                javadebugger-breakpointList-response
                                javadebugger-error-response
                                javadebugger-internalException-response
                                javadebugger-exception-response)))

(defvar javadebugger-breakpointList-functions nil)
(setq   javadebugger-breakpointList-functions nil)

(ht-set
 javadebug-response-functions
 javadebugger-breakpointList-response
 (lambda (response)
   (run-hook-with-args
    'javadebugger-breakpointList-functions
    (mapcar
     (lambda (x)
       (list
        (car x)
        (-slice x 1)))
     (-partition-in-steps 4 4 (-slice response  1))))))

(defun javadebugger-display-breakpoints (breakpoints)
  (writeStringToBuffer
   proxyProcess
   "Breakpoints")
  (writeOrgTableToBuffer
   proxyProcess
   "|id|location|\n"
   orgTableSeperator
   (mapcar
    (lambda (x)
      (list
       (nth 0 x)
       (concat (nth 0 (nth 1 x)) ":" (nth 1 (nth 1 x)))))
    breakpoints)))

(add-hook
 'javadebugger-breakpointList-functions
 'javadebugger-display-breakpoints)
#+END_SRC
**** catch

Request notification when an exception occurs in the target VM.

#+BEGIN_SRC emacs-lisp :tangle bugged.el

(ht-set
 commandHashMap
 "catch"
   (javadebug-makeCommandHashEntry "catch"
                               (lambda (c) (or (/= (length c) 2)  (and (not (string-match "on" (nth 1 c))) (not (string-match "off" (nth 1 c))))))
                               "catch on|off"
                               (lambda (proxy c)
                                 (process-send-string
                                  proxy
                                  (format
                                   "catch,%s\n"
                                   (nth 1 c))))
                               (list javadebugger-catchEnabled-response javadebugger-error-response javadebugger-internalException-response javadebugger-exception-response)))

(defvar javadebugger-catchEnabled-functions nil)
(setq javadebugger-catchEnabled-functions ())

(ht-set javadebug-response-functions
   javadebugger-catchEnabled-response
   (lambda (response) (run-hook-with-args 'javadebugger-catchEnabled-functions (nth 1 response))))

 (add-hook 'javadebugger-catchEnabled-functions
          (lambda (enabled)
            (writeStringToBuffer
             proc
             (format "Exceptions %s\n" (if (string= enabled "true") "enabled" "disabled")))))

(defvar javadebugger-exception-functions nil)
(setq javadebugger-exception-functions ())

(ht-set javadebug-response-functions
   javadebugger-exception-response
   (lambda (response)
     (run-hook-with-args
      'javadebugger-exception-functions
      (nth 1 response)
      (-slice response 2 5)
      (nth 5 response)
      (nth 0 (read-from-string (nth 6 response))))))

(add-hook 'javadebugger-exception-functions
          (lambda ( name loc message stack)
            (writeStringToBuffer
             proc
             (concat
              name " occured in target at " (javadebugger-LocationString loc) "\nMessage: " message "\nStack Trace:\n"))
            (let ((c (mapcar (lambda (x) (-slice (assoc "fields" x) 1))  (-slice (assoc "contents"  stack) 1))))
              (-each
                  (-partition 3
                              (-interleave
                               (mapcar (lambda (x) (nth 1 (assoc "fileName" x))) c)
                               (mapcar (lambda (x) (nth 1 (assoc "lineNumber" x))) c)
                               (mapcar (lambda (x) (nth 1 (assoc "methodName" x))) c)))
                (lambda (x) (writeStringToBuffer proc (format " %s\n" (javadebugger-LocationString x))))))))

#+END_SRC

**** classes

Print all classes loaded in the target VM.

#+BEGIN_SRC emacs-lisp :tangle bugged.el

(ht-set
 commandHashMap
 "classes"
   (javadebug-makeCommandHashEntry "classes"
                               (lambda (c) (/= (length c) 1))
                               "classes"
                               (lambda (proxy c)
                                 (process-send-string
                                  proxy
                                  "classes\n"))
                               (list javadebugger-classes-response javadebugger-error-response javadebugger-internalException-response javadebugger-exception-response)))

(defvar javadebugger-classes-functions nil)
(setq javadebugger-classes-functions ())
(ht-set javadebug-response-functions
   javadebugger-classes-response
   (lambda (response) (run-hook-with-args 'javadebugger-classes-functions  (-slice response 1))))

(add-hook 'javadebugger-classes-functions
          (lambda (classes)
            (writeStringToBuffer
             proc
             "classes\n")
            (dolist (r classes)
              (writeStringToBuffer
               proc
               (format "%s\n" r)))))

#+END_SRC
**** clear

Clear all breakpoints or the specified breakpoint.

#+BEGIN_SRC emacs-lisp :tangle bugged.el

(ht-set
 commandHashMap
 "clear"
   (javadebug-makeCommandHashEntry "clear"
                                   (lambda (c)
                                     (or (/= (length c) 2)
                                         (and
                                          (not (string-match "[0-9]+" (nth 1 c)))
                                          (not (string= "all" (nth 1 c))))))
                               "clear [breakpoint-id/all]"
                               (lambda (proxy c)
                                 (process-send-string
                                  proxy
                                  (format
                                   "clear,%s\n"
                                   (nth 1 c))))
                               (list javadebugger-breakpointList-response javadebugger-error-response javadebugger-internalException-response javadebugger-exception-response)))

(defvar javadebugger-breakpointCleared-functions nil)
(setq   javadebugger-breakpointCleared-functions nil)

(ht-set
 javadebug-response-functions
 javadebugger-breakpointCleared-response
 (lambda (response)
   (run-hook-with-args
    'javadebugger-breakpointList-functions
    (mapcar
     (lambda (x)
       (list
        (car x)
        (-slice x 1)))
     (-partition-in-steps 4 4 (-slice response  1))))))

(add-hook
 'javadebugger-breakpointCleared-functions
 'javadebugger-display-breakpoints)

#+END_SRC
**** down

Set the default frame to the frame directly below the current default frame.

#+BEGIN_SRC emacs-lisp :tangle bugged.el

(ht-set
 commandHashMap
 "down"
   (javadebug-makeCommandHashEntry "down"
                               (lambda (c) (/= (length c) 1))
                               "down"
                               (lambda (proxy c)
                                 (setq defaultFrame (1+ defaultFrame))
                                 (process-send-string
                                  proxy
                                  (format
                                   "stack,%s\n"
                                   defaultThread)))
                               (list javadebugger-stack-response javadebugger-error-response javadebugger-internalException-response javadebugger-exception-response)))
#+END_SRC

**** fields

Prints all the fields of a given class.

#+BEGIN_SRC emacs-lisp :tangle bugged.el

(ht-set
 commandHashMap
 "fields"
   (javadebug-makeCommandHashEntry "fields"
                               (lambda (c) (/= (length c) 2))
                               "fields"
                               (lambda (proxy c)
                                 (process-send-string
                                  proxy
                                  (format "fields,%s\n" (nth 1 c))))
                               (list  javadebugger-fields-response javadebugger-error-response javadebugger-internalException-response javadebugger-exception-response)))

(defvar javadebugger-fields-functions nil)
(setq javadebugger-fields-functions ())
(ht-set javadebug-response-functions
   javadebugger-fields-response
   (lambda (response) (run-hook-with-args 'javadebugger-fields-functions  (nth 1 response) (-partition-in-steps 8 8 (-slice response 2)))))

(add-hook 'javadebugger-fields-functions
          (lambda (className fields)
            (writeOrgTableToBuffer
             proxyProcess
             "|Class|Name|Type|Declaring Type|Enum|Transient|Volatile|Final|Static|\n"
             (list className fields))))

#+END_SRC

**** frame

#+BEGIN_SRC emacs-lisp :tangle bugged.el

(ht-set
 commandHashMap
 "frame"
   (javadebug-makeCommandHashEntry "frame"
                               (lambda (c) (/= (length c) 1))
                               "frame (default thread) (defaultFrame)"
                               (lambda (proxy c)
                                 (process-send-string
                                  proxy
                                  (format
                                   "frame,%s,%s\n"
                                   defaultThread
                                   defaultFrame)))
                               (lambda (r) (string= (car r) "arguments"))))
#+END_SRC
**** help

Prints a short description of every debugger command.

#+BEGIN_SRC emacs-lisp :tangle bugged.el

(ht-set
 commandHashMap
 "help"
   (javadebug-makeCommandHashEntry "help"
                               (lambda (c) ())
                               "help"
                               (lambda (proxy c)
                                 (dolist (v
                                          (sort (ht-map (lambda (key value) (javadebug-hashDescribeCommand value)) commandHashMap) 'string<))
                                  (writeStringToBuffer proxy (concat v "\n")))
                                 (setq runningCommand ())
                                 (javadebug-fix-output-buffer proxyProcess))
                               (lambda (r) (string= (car r) "help"))))
#+END_SRC

**** wait

For use in command lists. Pauses execution of commands in the list until a
breakpoint is entered or a class is prepared.


Now this is a fairly amusing command.

It's entered like this:

     wait breakpointentered

or

     wait classprepared.

In the first case it sends a run command to the proxy and waits for a
breakpointentered response. In the second, it sends a run command to the proxy
and waits for a classprepared response.

When runningCommand is set to this command and the command is executed (i.e. the
second lamda expression in the commandHashEntry runs) the code looks in
runningCommand, picks out the commandHashEnry, picks the response list field out
of the commandHashEntry, and sets it to a list containing - among other things,
the second argument of the wait command. All this happens in the setf instruction
below.

#+BEGIN_SRC emacs-lisp :tangle bugged.el

(ht-set
 commandHashMap
 "wait"
   (javadebug-makeCommandHashEntry "wait"
                               (lambda (c) (/= (length c) 2))
                               "wait"
                               (lambda (proxy c)
                                 (setf
                                  (nth 4 (nth 3 runningCommand))
                                  (list (nth 1 c) javadebugger-error-response javadebugger-internalException-response javadebugger-exception-response))
                                 (process-send-string
                                  proxy
                                  "run\n"))
                               ()))

(defvar javadebugger-classPrepared-functions nil)
(setq javadebugger-classPrepared-functions ())
(ht-set javadebug-response-functions
   javadebugger-classPrepared-response
   (lambda (response) (run-hook-with-args 'javadebugger-classPrepared-functions response)))

(add-hook 'javadebugger-classPrepared-functions (lambda ( resp)
            (writeStringToBuffer proc (concat  (s-join " " resp) ".\n"))))

#+END_SRC

**** locals

Print local variables with their values.

By default prints all local variables but can specify the variables to print
with a variable descriptor string.

#+BEGIN_SRC emacs-lisp :tangle bugged.el

(ht-set
 commandHashMap
 "locals"
 (javadebug-makeCommandHashEntry
  "locals"
  (lambda (c) (and (/= (length c) 1) (/= (length c) 2)))
  "locals [variable names]"
  (lambda (proxy c)
    (process-send-string
     proxy
     (format
      "locals,%s,%s,%s\n"
      defaultThread
      (number-to-string defaultFrame)
      (if (= (length c) 2) (nth 1 c) "*"))))
  (list javadebugger-locals-response javadebugger-error-response javadebugger-internalException-response javadebugger-exception-response)))

(defvar javadebugger-locals-functions nil)
(setq javadebugger-locals-functions ())
(ht-set javadebug-response-functions
        javadebugger-locals-response
        (lambda (response)
          (run-hook-with-args
           'javadebugger-locals-functions
           (nth 1 response)
      (nth 2 response)
      (nth 0 (read-from-string (nth 3 response))))))

(add-hook
 'javadebugger-locals-functions
 (lambda (thread frame th)
   (writeStringToBuffer
    proxyProcess
    (format "Locals for thread %s frame number %s.\n" thread frame))
   (writeOrgTableToBuffer
    proxyProcess
    "| Name | Value |\n"
    orgTableSeperator
    th)))

#+END_SRC

**** back, into, next

Execute a single step in the target VM.

back - step out of the current frame
into - step to the next location on a different line or into a new frame,
next - step to the next location on a different line and over a new frame.

#+BEGIN_SRC emacs-lisp :tangle bugged.el

(ht-set
 commandHashMap
 "back"
   (javadebug-makeCommandHashEntry "back"
                               (lambda (c) (or (> (length c) 2)  (and (= (length c) 2) (not (string-match "[0-9]+" (nth 1 c))))))
                               "back [thread-id]"
                               (lambda (proxy c)
                                 (process-send-string
                                  proxy
                                  (format
                                   "back,%s\n"
                                   (if (= (length c) 1) defaultThread (nth 1 c)))))
                               (list javadebugger-stepCreated-response javadebugger-error-response javadebugger-internalException-response javadebugger-exception-response)))

(ht-set
 commandHashMap
 "into"
   (javadebug-makeCommandHashEntry "into"
                               (lambda (c) (or (> (length c) 2)  (and (= (length c) 2) (not (string-match "[0-9]+" (nth 1 c))))))
                               "into [thread-id]"
                               (lambda (proxy c)
                                 (process-send-string
                                  proxy
                                  (format
                                   "into,%s\n"
                                   (if (= (length c) 1) defaultThread (nth 1 c)))))
                               (list javadebugger-stepCreated-response javadebugger-error-response javadebugger-internalException-response javadebugger-exception-response)))

(ht-set
 commandHashMap
 "next"
   (javadebug-makeCommandHashEntry "next"
                               (lambda (c) (or (> (length c) 2)  (and (= (length c) 2) (not (string-match "[0-9]+" (nth 1 c))))))
                               "next [thread-id]"
                               (lambda (proxy c)
                                 (process-send-string
                                  proxy
                                  (format
                                   "next,%s\n"
                                   (if (= (length c) 1) defaultThread (nth 1 c)))))
                               (list javadebugger-stepCreated-response javadebugger-error-response javadebugger-internalException-response javadebugger-exception-response)))

(defvar javadebugger-stepCreated-functions nil)
(setq javadebugger-stepCreated-functions ())
(ht-set javadebug-response-functions
   javadebugger-stepCreated-response
   (lambda (response) (run-hooks 'javadebugger-stepCreated-functions )))

;;(add-hook 'javadebugger-stepCreated-functions (lambda ()

(defvar javadebugger-step-functions nil)
(setq javadebugger-step-functions ())
(ht-set javadebug-response-functions
   javadebugger-step-response
   (lambda (response) (run-hook-with-args 'javadebugger-step-functions  (-slice response 1 7) (-slice response 7))))

(add-hook 'javadebugger-step-functions
        (lambda (tr loc)
            (reportBreak "step" tr loc)))

#+END_SRC

**** modify

Set a modification watchpoint.

Request notification when a field is set. This event will be triggered when a
value is assigned to the specified field with a Javatatement (assignment,
increment, etc) or by a Java Native Interface (JNI) set function Setting a field
to a value which is the same as the previous value still triggers this event.

#+BEGIN_SRC emacs-lisp :tangle bugged.el

(ht-set
 commandHashMap
 "modify"
   (javadebug-makeCommandHashEntry "modify"
                               (lambda (c) (/= (length c) 3))
                               "modify class-name field-name"
                                (lambda (proxy c)
                                 (process-send-string
                                  proxy
                                  (format
                                  "modify,%s,%s\n"
                                   (nth 1 c)
                                   (nth 2 c))))
                               (list javadebugger-modificationWatchpointSet-response javadebugger-error-response javadebugger-internalException-response javadebugger-exception-response)))

(defvar javadebugger-modificationWatchpointSet-functions nil)
(setq javadebugger-modificationWatchpointSet-functions ())
(ht-set javadebug-response-functions
   javadebugger-modificationWatchpointSet-response
   (lambda (response) (run-hooks 'javadebugger-modificationWatchpointSet-functions )))

(add-hook 'javadebugger-modificationWatchpointSet-functions (lambda ()
            (writeStringToBuffer proc (concat "Modification watchpoint set.\n"))))

(defvar javadebugger-modificationWatchpoint-functions nil)
(setq javadebugger-modificationWatchpoint-functions ())
(ht-set javadebug-response-functions
   javadebugger-modificationWatchpoint-response
   (lambda (response)
     (run-hook-with-args 'javadebugger-modificationWatchpoint-functions
                         (nth 1 response)
                         (nth 2 response)
                         (nth 0 (read-from-string (nth 3 response)))
                         (nth 0 (read-from-string (nth 4 response))))))

(add-hook
 'javadebugger-modificationWatchpoint-functions
 (lambda (className fieldName past future)
   (writeStringToBuffer proxyProcess "Modification watchpoint\n")
   (writeOrgTableToBuffer
    proxyProcess
    "| Object:Field | When | Value |\n"
    orgTableSeperator
    (list (concat className ":" fieldName) (list "Before" past) (list "After" future)))))

#+END_SRC

**** prepare

Request notification when a class is prepared in the target VM.

#+BEGIN_SRC emacs-lisp :tangle bugged.el

(ht-set
 commandHashMap
 "prepare"
   (javadebug-makeCommandHashEntry "prepare"
                               (lambda (c) (/= (length c) 2))
                               "prepare [class name]"
                               (lambda (proxy c)
                                 (process-send-string
                                  proxy
                                  (format "prepare,%s\n" (nth 1 c))))
                               (list javadebugger-preparingClass-response javadebugger-error-response javadebugger-internalException-response javadebugger-exception-response)))

(defvar javadebugger-preparingClass-functions nil)
(setq javadebugger-preparingClass-functions ())
(ht-set javadebug-response-functions
   javadebugger-preparingClass-response
   (lambda (response) (run-hook-with-args 'javadebugger-preparingClass-functions  (nth 1 response))))

(add-hook 'javadebugger-preparingClass-functions (lambda (name)
            (writeStringToBuffer proc (concat "Preparing class " name ".\n"))))

#+END_SRC

**** quit

End the debugging session.

#+BEGIN_SRC emacs-lisp :tangle bugged.el

(ht-set
 commandHashMap
 "quit"
   (javadebug-makeCommandHashEntry "quit"
                               (lambda (c) (/= (length c) 1))
                               "quit"
                               (lambda (proxy c)
                                 (process-send-string
                                  proxy
                                  "quit\n"))
                               (lambda (r) (string= (car r) "proxy"))))

(defvar javadebugger-proxyExited-functions nil)
(setq javadebugger-proxyExited-functions ())
(ht-set javadebug-response-functions
   javadebugger-proxyExited-response
   (lambda (response) (run-hooks 'javadebugger-proxyExited-functions )))

(add-hook 'javadebugger-proxyExited-functions (lambda ()
            (writeStringToBuffer proxyProcess "Debugger proxy exited\n")))

(defvar javadebugger-vmDisconnected-functions nil)
(setq javadebugger-vmDisconnected-functions ())
(ht-set javadebug-response-functions
   javadebugger-vmDisconnected-response
   (lambda (response) (run-hooks 'javadebugger-vmDisconnected-functions )))

(add-hook 'javadebugger-vmDisconnected-functions (lambda ()
        (writeStringToBuffer proxyProcess "virtual machine disconnected\n")))

(defvar javadebugger-vmDied-functions nil)
(setq javadebugger-vmDied-functions ())
(ht-set javadebug-response-functions
   javadebugger-vmDied-response
   (lambda (response) (run-hooks 'javadebugger-vmDied-functions )))

(add-hook 'javadebugger-vmDied-functions (lambda ()
        (writeStringToBuffer proxyProcess "virtual machine terminated\n")))

#+END_SRC

**** run

Start or resume program execution.

#+BEGIN_SRC emacs-lisp :tangle bugged.el

(ht-set
 commandHashMap
 "run"
   (javadebug-makeCommandHashEntry "run"
                               (lambda (c) (/= (length c) 1))
                               "run"
                               (lambda (proxy c)
                                 (process-send-string
                                  proxy
                                  "run\n"))
                               (list javadebugger-vmResumed-response javadebugger-error-response javadebugger-internalException-response javadebugger-exception-response)))

(ht-set
 commandHashMap
 "continue"
   (javadebug-makeCommandHashEntry "continue"
                               (lambda (c) (/= (length c) 1))
                               "continue"
                               (lambda (proxy c)
                                 (process-send-string
                                  proxy
                                  "run\n"))
                               (list javadebugger-vmResumed-response javadebugger-error-response javadebugger-internalException-response javadebugger-exception-response)))

(defvar javadebugger-vmResumed-functions nil)
(setq javadebugger-vmResumed-functions ())
(ht-set javadebug-response-functions
   javadebugger-vmResumed-response
   (lambda (response) (run-hooks 'javadebugger-vmResumed-functions )))

(add-hook 'javadebugger-vmResumed-functions (lambda ()
        (writeStringToBuffer proxyProcess "virtual machine resuming operation.\n")))

#+END_SRC

**** set

Set the defaultThread which will be used by future commands. Use the 'threads'
command to get a list of threads and their ids.

#+BEGIN_SRC emacs-lisp :tangle bugged.el

(ht-set
 commandHashMap
 "set"
   (javadebug-makeCommandHashEntry "set"
                               (lambda (c) (or (/= (length c) 2)  (not (string-match "[0-9]+" (nth 1 c)))))
                               "set [thread-id]"
                               (lambda (proxy c)
                                 (setq defaultThread (nth 1 c))
                                 (process-send-string
                                  proxy
                                  "threads\n"))
                               (list javadebugger-threadList-response javadebugger-error-response javadebugger-internalException-response javadebugger-exception-response)))

#+END_SRC

**** stack

Print the stack of method calls which have brought us to this point.

#+BEGIN_SRC emacs-lisp :tangle bugged.el

(ht-set
 commandHashMap
 "stack"
   (javadebug-makeCommandHashEntry "stack"
                               (lambda (c) (/= (length c) 1))
                               "stack"
                               (lambda (proxy c)
                                 (process-send-string
                                  proxy
                                  (format
                                   "stack,%s\n"
                                   defaultThread)))
                               (list javadebugger-stack-response javadebugger-error-response javadebugger-internalException-response javadebugger-exception-response)))

(defvar javadebugger-stack-functions nil)
(setq javadebugger-stack-functions ())
(ht-set javadebug-response-functions
   javadebugger-stack-response
   (lambda (response) (run-hook-with-args 'javadebugger-stack-functions (nth 1 response) (-partition-in-steps 3 3 (-slice response 2)))))

(add-hook 'javadebugger-stack-functions
          (lambda (id locations)
            (writeStringToBuffer proxyProcess (concat "Stack for thread " id " \n"))
            (writeOrgTableToBuffer
             proxyProcess
             "||Frame|File|Line|Method|\n"
             orgTableSeperator
             (let ((ff ())
                   (locs locations))
               (dotimes (i (length locs))
                 (setq ff
                       (cons
                        (cons
                         (if (= i defaultFrame) "*" "")
                         (cons
                          (number-to-string i)
                          (nth i locs)))
                        ff)))
               (reverse ff)))
            (when (< defaultFrame (length locations))
              (let ((loc (nth defaultFrame locations)))
                (setSourceFileWindow
                 proxyProcess
                 (locationFile loc)
                 (locationLineNumber loc))))))

#+END_SRC

**** this

Prints the object pointed to by the 'this' JAVA keyword in the default thread
and default frame.

#+BEGIN_SRC emacs-lisp :tangle bugged.el

(ht-set
 commandHashMap
 "this"
 (javadebug-makeCommandHashEntry
  "this"
  (lambda (c) (and (/= (length c) 1) (/= (length c) 2)))
  "this [default-thread-id] [default-frame number]"
  (lambda (proxy c)
    (process-send-string
     proxy
     (format
      "this,%s,%s\n"
      defaultThread
      (number-to-string defaultFrame))))
  (list  javadebugger-this-response javadebugger-error-response javadebugger-internalException-response javadebugger-exception-response)))

(defvar javadebugger-this-functions nil)
(setq javadebugger-this-functions ())

(ht-set
 javadebug-response-functions
 javadebugger-this-response
 (lambda (response)
   (run-hook-with-args
    'javadebugger-this-functions
    (nth 1 response)
    (nth 2 response)
    (nth 0 (read-from-string (nth 3 response))))))

(add-hook
 'javadebugger-this-functions
 (lambda (thread frame th)
   (writeStringToBuffer
    proxyProcess
    (format "This for thread %s frame number %s.\n" thread frame))
   (writeOrgTableToBuffer
    proxyProcess
    thisTableTitle
    orgTableSeperator
    th)))

#+END_SRC

**** threads

Prints the running threads and their status.

#+BEGIN_SRC emacs-lisp :tangle bugged.el

(ht-set
 commandHashMap
 "threads"
   (javadebug-makeCommandHashEntry "threads"
                                   (lambda (c) (/= (length c) 1))
                                   "threads"
                                   (lambda (proxy c)
                                     (process-send-string
                                      proxy
                                      "threads\n"))
                               (list javadebugger-threadList-response javadebugger-error-response javadebugger-internalException-response javadebugger-exception-response)))

(defvar javadebugger-threadList-functions nil)
(setq javadebugger-threadList-functions ())
(ht-set javadebug-response-functions
   javadebugger-threadList-response
   (lambda (response) (run-hook-with-args 'javadebugger-threadList-functions (-partition-in-steps 6 6 (-slice response 1)))))

(add-hook 'javadebugger-threadList-functions
          (lambda (threads)
            (writeOrgTableToBuffer
             proxyProcess
             threadTableTitle
             orgTableSeperator
             threads)))

#+END_SRC

**** up

Decrement defaultFrame moving it closer to the current frame.

#+BEGIN_SRC emacs-lisp :tangle bugged.el

(ht-set
 commandHashMap
 "up"
   (javadebug-makeCommandHashEntry "up"
                               (lambda (c) (or (/= (length c) 1) (<= defaultFrame 0)))
                               "up"
                               (lambda (proxy c)
                                 (setq defaultFrame (1- defaultFrame))
                                 (process-send-string
                                  proxy
                                  (format
                                   "stack,%s\n"
                                   defaultThread)))
                               (list javadebugger-stack-response javadebugger-error-response javadebugger-internalException-response javadebugger-exception-response)))
#+END_SRC

*** Miscellaneous responses from the debugger proxy

#+BEGIN_SRC emacs-lisp :tangle bugged.el

(defvar javadebugger-classUnloaded-functions nil)
(setq javadebugger-classUnloaded-functions ())
(ht-set javadebug-response-functions
   javadebugger-classUnloaded-response
   (lambda (response) (run-hook-with-args 'javadebugger-classUnloaded-functions (nth 1 response))))

;;(add-functions 'javadebugger-classUnloaded-functions (lambda ( className)

(defvar javadebugger-error-functions nil)
(setq javadebugger-error-functions ())
(ht-set javadebug-response-functions
   javadebugger-error-response
   (lambda (response) (run-hook-with-args 'javadebugger-error-functions (nth 1 response))))

(add-hook 'javadebugger-error-functions (lambda ( error)
            (writeStringToBuffer proc (concat "Error: "  error "\n"))))

;; internalException
(defvar javadebugger-internalException-functions nil)
(setq javadebugger-internalException-functions ())
(ht-set javadebug-response-functions
   javadebugger-internalException-response
        (lambda (response) (run-hook-with-args 'javadebugger-internalException-functions (nth  1 response) (nth 2 response))))

(add-hook 'javadebugger-internalException-functions
          (lambda (msg stack)
            (writeStringToBuffer proc (concat "Internal exception in proxy: " msg "\n" stack "\n"))))

;; log
(defvar javadebugger-log-functions nil)
(setq javadebugger-log-functions ())
(ht-set javadebug-response-functions
   javadebugger-log-response
   (lambda (response) (run-hook-with-args 'javadebugger-log-functions (nth 1 response))))

;; log
(add-hook 'javadebugger-log-functions (lambda ( resp)
            (writeStringToBuffer proc (concat  (s-join " " resp) ".\n"))))

;; proxyStarted
(defvar javadebugger-proxyStarted-functions nil)
(setq javadebugger-proxyStarted-functions ())
(ht-set javadebug-response-functions
   javadebugger-proxyStarted-response
   (lambda (response) (run-hooks 'javadebugger-proxyStarted-functions )))

(add-hook 'javadebugger-proxyStarted-functions (lambda ()
            (writeStringToBuffer proxyProcess "Debugger proxy started\n")))

;; threadDied
(defvar javadebugger-threadDied-functions nil)
(setq javadebugger-threadDied-functions ())
(ht-set javadebug-response-functions
   javadebugger-threadDied-response
   (lambda (response) (run-hook-with-args 'javadebugger-threadDied-functions  (-slice response 1 7))))

;;(add-functions 'javadebugger-threadDied-functions (lambda ( tr)

;; threadStarted
(defvar javadebugger-threadStarted-functions nil)
(setq javadebugger-threadStarted-functions ())
(ht-set javadebug-response-functions
   javadebugger-threadStarted-response
   (lambda (response) (run-hook-with-args 'javadebugger-threadStarted-functions  (-slice response 1 7))))

;; threadStarted
;;(add-functions 'javadebugger-threadStarted-functionsn (lambda ( tr)

(defun javadebugger-LocationString (l) (format "%s:%s %s" (locationFile l) (locationLineNumber l) (locationMethod l)))

#+END_SRC
