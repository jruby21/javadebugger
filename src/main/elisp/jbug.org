* Java Debugger
** Introduction

JbugMode is a replacement for the combination of the GUD/JDP emacs mode and
the Oracle command line debugger jdb. This combination will be refered to as jdb
in what follows.

JbugMode will seem familiar to anyone experienced with jdb. The commands
are similar and the overall feeling is that of a command line program with an
emacs mode as a front end.

Its overall design is also similar to jdb. There is an elisp program which
implements an emacs mode - in this case a minor mode called jbug-mode
derived from Org mode - and an proxy program written in JAVA which uses the JAVA
JDI interface to communicate with the program to be debugged and stdin/stdout to
communicate with the elisp program.

JbugMode has certain advantages over jdb. For one, it works. For another,
it is easy to install and configure. Also, JbugMode looks into variables;
for example, instead of displaying the number of bins in a hash table it will
show the key/value pairs in the table. It is easy to change or script the
debugger in elisp. And the debugging session is kept in an org buffer which can
be saved or exported as the user desires.

The debugger is basicly four command streams and the code to handle them.

The first command stream is the user's input to the elisp program. The commands
are seperated by newlines and each command is a series of ASCII tokens seperated
by spaces. The first token in a line identifies the command and the rest of the
tokens are arguments to that command. The first token is the key to a hash table
(jbug-commandHashMap), the entry in the hash table describes the action to be
taken on receipt of the command.

The elisp program writes the second command stream to its standard output while
the JAVA proxy reads it from its standard input.  The commands are seperated by
newlines, each command is a series of ASCII tokens, seperated by commas. The
first token names the command and is the key to a hash table identifying the
action to be taken on receipt of the command.

The third command stream is a queue of objects signalling asynchronous
events. The JDI creates the third stream and a thread  in the JAVA proxy reads
it.

The JAVA proxy writes the fourth command stream to its standard output. The
elisp program reads it from its standard input. The stream is a sequence of
ASCII tokens seperated by newlines. Each line is a command is a series of tokens
seperated by commas. The first token first token identifies the command and is
the key to a hash table (jbug-response-hash-table) in the elisp program which
describes the action to be taken on receipt of the command.

The elisp program contains code to create and respond to each command it sends
and receives. There is some code in the elisp program to display data read from
the debugger proxy and some code in the debugger proxy to look inside of
variables (DebuggerOutput.java).  That's about it.

** Boilerplate

#+BEGIN_SRC emacs-lisp :tangle jbug.el
;;; -*- lexical-binding: t; -*-

;;; jbug.el --- An Emacs based JAVA debugger

;;; Copyright (C) 2010-2018 Jonathan Ruby

;; Author: Jonathan Ruby <jruby21@protonmail.com>
;; Maintainer: Jonathan Ruby <jruby21@protonmail.com>
;; Created: 18 August 2018
;; Keywords: tools
;; Homepage: https://github.com/jruby21/javadebugger

;; This file is not part of GNU Emacs.

;; This file is free software

;;    This file is part of jbug.

;;    jbug is free software: you can redistribute it and/or modify
;;    it under the terms of the GNU General Public License as published by
;;    the Free Software Foundation, either version 3 of the License, or
;;    (at your option) any later version.

;;    jbug is distributed in the hope that it will be useful,
;;    but WITHOUT ANY WARRANTY; without even the implied warranty of
;;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;;    GNU General Public License for more details.

;;    You should have received a copy of the GNU General Public License
;;    along with jbug.  If not, see <https://www.gnu.org/licenses/>.

;;; Commentary:

;;    For documentation of the code, see the org babel file 'jbug.org'
;;    available at https://github.com/jruby21/javadebugger/tree/master/src/main/elisp/jbug.orgp

;;; Code:

#+END_SRC

** Require

#+BEGIN_SRC emacs-lisp :tangle jbug.el

; jbugMode requires loading these four emacs packages:

;   bm
;   dash
;   ht
;   s

(require 'bm)
(require 'dash)
(require 'ht)
(require 's)

#+END_SRC

** jbug mode

The elisp program as a mode name jbug-mode. The mode is derived from ORG
mode.

#+BEGIN_SRC emacs-lisp :tangle jbug.el

;;;###autoload
(defvar jbug-mode-map
  (let ((map (make-sparse-keymap)))
    (define-key map (kbd "RET") 'jbug-newline)
    (define-key map (kbd "M-p") 'jbug-previous-command-in-history)
    (define-key map (kbd "M-n") 'jbug-next-command-in-history)
    map))

;;;###autoload
(define-derived-mode jbug-mode
  org-mode "Jbug"
  "Major mode java debugger.")

(defcustom jbug-mode-hook nil
  "Mode hook for Org mode, run after the mode was turned on."
  :group 'jbug
  :type 'hook)

(defvar jbug-defaultThread "1" "The last thread in which we had a breakpoint.  Use this thread if no thread number is specified in a command.")
(defvar jbug-defaultFrame  0   "The frame to examine.")

#+END_SRC

** The Proxy

There is a JAVA prgram called the 'proxy' which connects to the target process
and handles the JDI interface.  The proxy runs as a sub process to emacs. This
elisp program sends commands to the proxy on stdin and receives replies on
stdout.

Normally, we assume that the jar files containing the proxy classes and the JDI
classes are in the same directory as this script. We find the directory name of
the file for this script and create the shell command for the proxy from that
name. However, a user can give a different shell command to start the proxy by
setting it as the value of the jbug-proxy-command variable.

#+BEGIN_SRC emacs-lisp :tangle jbug.el
(defvar jbug-proxyProcess () "The JAVA proxy program which connects to the program to be debugged.")

(defconst
  jbug-toolsJar
  "tools.jar"
  "The jar containing the JDI java debugger api (JDI) classes.")

(defconst
  jbug-jbugJar
  "jbug.jar"
  "The jar containing the jbug proxy classes.")

(defcustom
  jbug-proxy-command
  nil
  "If not nil the full shell command to run the proxy program, if nil create the command programmatically."
  :type '(string)
  :group 'jbug)

(defvar
  jbug-receivedFromProxy
  ""
  "Concat return values from process filter in this variable")

(defun jbug-get-proxy-command()
  "Return the shell command to start the proxy program."
  (if jbug-proxy-command
      jbug-proxy-command
    (let ((base (file-name-directory (find-lisp-object-file-name major-mode nil))))
      (concat
       " java -cp "
       (expand-file-name jbug-jbugJar base)
       (if (or (eq system-type  'ms-dos) (eq system-type 'windows-nt)) ";" ":")
       (expand-file-name jbug-toolsJar base)
       " com.github.jruby21.javadebugger.JavaDebuggerProxy"))))

#+END_SRC

*** Start the proxy

Start the proxy and set the filter which handles strings received on stdin from
the proxy.  There is a special debugger command (proxy) that does nothing but
wait for the proxy to signal that it has started. Execute the command.

#+BEGIN_SRC emacs-lisp :noweb-ref start-proxy

(setq jbug-commandsToRun ())
(setq jbug-runningCommand
      (jbug-describeRunnableCommand
       "proxy"
       "proxy"
       (list "proxy")
       (jbug-makeCommandHashEntry
       "proxy"
        (lambda (_c) ())
        ""
        (lambda (_c) ""))))

(message "proxy jars: %s %s" major-mode (jbug-get-proxy-command))

;; delete any previously created proxies

(dolist (p (process-list))
  (if (s-starts-with? "jbugProxy" (process-name p))
      (delete-process p)))

;; start a new proxy

(setq jbug-receivedFromProxy "")
(setq jbug-proxyProcess (apply 'start-process "jbugProxy"  (current-buffer) (split-string (jbug-get-proxy-command))))
(set-process-filter jbug-proxyProcess 'jbug-insertion-filter)
(set-process-query-on-exit-flag jbug-proxyProcess nil)

#+END_SRC

** Debugger Commands

These are the commands a user can enter to the debugger.

A list created by the function jbug-makeCommandHashEntry describes a command.

A hash table called jbug-commandHashMap contains the lists.  The string a user
enters to invoke a command indexes the map so the command can be found when a
user enters it.

#+BEGIN_SRC emacs-lisp :tangle jbug.el
(defun jbug-makeCommandHashEntry (hashKey badCommandP describeCommand executeCommand)
  "Create the list which defines a command in the CommandHashMap.
HASHKEY         - the command name
BADCOMMANDP     - a function returning true if the command syntax is incorrect.
DESCRIBECOMMAND - a string describing the command
EXECUTECOMMAND  - a function which executes the command"
  (list hashKey badCommandP describeCommand executeCommand))

(defun jbug-hashKey             (hashEntry)
  "Gets the command name from the CommandHashEntry HASHENTRY."
  (nth 0 hashEntry))

(defun jbug-hashBadCommandP     (hashEntry)
  "Gets the command syntax checker from the CommandHashEntry HASHENTRY."
  (nth 1 hashEntry))

(defun jbug-hashDescribeCommand (hashEntry)
  "Gets the command description from the CommandHashEntry HASHENTRY."
  (nth 2 hashEntry))

(defun jbug-hashDoCommand       (hashEntry)
  "Gets the command execution function from the CommandHashEntry HASHENTRY."
  (nth 3 hashEntry))

(defun jbug-badCommandP    (e f)
  "Execute the syntax checker from the CommandHashMapEntry E on the command F."
  (funcall (jbug-hashBadCommandP e) f))

(defun jbug-doCommand  (e p f)
  "Execute the the command F on the proxy P using the CommandHashMapEntry E."
  (funcall (jbug-hashDoCommand e)   p f))

(defconst jbug-commandHashMap
  (ht-create)
  "Create the map containing all the commands.")

#+END_SRC

The code to fill jbug-commandHashMap is found in a later section.

*** Input a command

Input to the elisp program comes from the org buffer created when the mode
starts. The user enters a line at the end of the buffer and types a
newline. That line goes to this elisp program because the mode puts a new
routine for newline into its keymap.

When a user adds a line to the very bottom of the buffer the line is treated as
a command. Otherwise, it is just an ordinary line in a ORG buffer.

Multiple commands can be entered if they are seperated by a semicolon. Each
individual command is a series of tokens seperated by blanks. The first token
identifies the command.

#+BEGIN_SRC emacs-lisp :tangle jbug.el

(defvar jbug-point-in-history 1 "Points to the current position in command history.")

(defun jbug-newline ()
  "Handles the newline key in jbug mode.
Acts like a newline in org mode except when at the very end of
the buffer where it treats the line as a command to the
debugger."
  (interactive)
  (if (/=  (line-end-position) (point-max))
      (org-return)
    (beginning-of-line)
    (let ((com (if (looking-at "[ \t]*-?>?[ \t]*\\(\\([a-zA-Z]?.*\\)\\)")
                  (match-string 1)
                ())))
      (ignore-errors (kill-line))  ;; kill-line signals an error at the end of buffer
      (if (not com)
          (insert "-> ")
        (setq jbug-point-in-history 0)
        (message "jbug-newline: com: %s" com)
        (jbug-add-commands (split-string com ";" 't))))))
#+END_SRC

There is a command history.

#+BEGIN_SRC emacs-lisp  :tangle jbug.el

(defun jbug-get-old-command (count)
  "Return the COUNT'th previous command."
  (save-excursion
    (goto-char (point-max))

    (while
        (and
         (> count 0)
         (outline-previous-heading))
      (if
          (and
           (outline-on-heading-p 't)
           (= (- (match-end 0) (match-beginning 0) 1) 3))
          (setq count (1- count))))

    (if
        (and
         (= count 0)
         (outline-on-heading-p 't)
         (= (- (match-end 0) (match-beginning 0) 1) 3))
        (s-trim
         (buffer-substring-no-properties (match-end 0) (progn (end-of-line) (point))))
      ())))

(defun jbug-previous-command-in-history ()
  "Get's the previous command."
  (interactive)
  (goto-char (point-max))
  (let ((command (jbug-get-old-command (1+ jbug-point-in-history))))
    (when
        command
      (jbug-position-old-command command)
      (setq jbug-point-in-history (1+ jbug-point-in-history)))))

(defun jbug-next-command-in-history ()
  "Get's the next command."
  (interactive)
  (goto-char (point-max))
  (when
      (> jbug-point-in-history 1)
    (let ((command (jbug-get-old-command (1- jbug-point-in-history))))
      (when
          command
        (jbug-position-old-command command)
        (setq jbug-point-in-history (1- jbug-point-in-history))))))

(defun jbug-position-old-command (command)
  "Insert a command COMMAND into the end of the jbug mode buffer."
  (goto-char (point-max))
  (beginning-of-line)
  (ignore-errors (kill-line))  ;; kill-line signals an error at the end of buffer
  (insert command))

#+END_SRC

This is the code which runs when the user enters a command. A lot of the work is
done by the jbug-check-commands routine which goes through the list of
commands, looks each one up in the jbug-commandHashMap, checks the entered string
with the routine kept in the jbug-hashBadCommandP entry in the command's
CommandHashEntry, puts all the good commands in one list, the bad commands in
another, and returns the two lists. If there are any errors, they are printed
out. If all the commands are good, they are queued for execution by being added
to the jbug-commandsToRun list. At the end we run jbug-execute-command which may
send a command to the proxy.

#+BEGIN_SRC emacs-lisp :tangle jbug.el

(defvar jbug-commandsToRun  () "The list of commands waiting to be sent to the proxy.")

(defun jbug-add-commands (com)
  "Check the syntax of each command in the list COM.
If it is valid, put it on the list of commands to be run.
Execute the first command on the list if no other command is in
process."
  (let* ((r (jbug-check-commands com))
         (good (jbug-check-commands-good r))
         (bad  (jbug-check-commands-bad r)))
    (if (null bad)
        (setq jbug-commandsToRun (append jbug-commandsToRun good))
      (dolist (v bad)
        (writeStringToBuffer jbug-proxyProcess (concat v "\n")))
      (jbug-fix-output-buffer jbug-proxyProcess)))
  (jbug-execute-command))

(defun jbug-check-commands (cm)
  "Check the syntax of each member of a list of commands CM."
  (let ((checkErrors ())
        (goodCommands ()))
    (dolist (v cm)
      (let* ((c (split-string v " "  't))
             (hashEntry (ht-get jbug-commandHashMap (car c))))
        (if (null hashEntry)
            (setq checkErrors (append checkErrors (list (concat "error - no such command: " v))))
          (if (jbug-badCommandP hashEntry c)
              (setq checkErrors (append checkErrors (list (concat "error - bad command format " v ". Try "  (jbug-hashDescribeCommand hashEntry)))))
            (setq goodCommands
                  (-snoc
                   goodCommands
                   (jbug-describeRunnableCommand
                    (jbug-hashKey hashEntry)
                    v
                    c
                    hashEntry)))))))

    (list goodCommands checkErrors)))

(defun jbug-check-commands-good (ls)
  "Pull the valid commands out of the list of commands LS  returned by jbug-check-commands."
  (nth 0 ls))

(defun jbug-check-commands-bad   (ls)
  "Pull the invalid commands out of the list of commands LS  returned by jbug-check-commands."
  (nth 1 ls))

#+END_SRC

*** Describing a Command Waiting to be Executed

What exactly gets put on the jbug-commandsToRun queue?

Another list pretending to be an object. This list was created in
jbug-check-commands.

The contents of the list are:

0. the comand key in the hash table commandList
1. the command as it was entered
2. the command as it was entered split on blanks into a list
3. the command's entry in the hash table jbug-commandHashMap.

An entry in the list is created by the jbug-describeRunnableCommand.

#+BEGIN_SRC emacs-lisp :tangle jbug.el
(defun jbug-describeRunnableCommand (key entered split entry)
  "Return a list which describes a command to be run by the debugger.
KEY     - the comand key in the hash table commandList
ENTERED - the command as it was entered
SPLIT   -  the command as it was entered split on blanks into a list
ENTRY   - the command's entry in the hash table jbug-commandHashMap."

  (list key entered split entry))

(defun getKeyFromCommandDescription      (cp) "Get the command name from the running command descriptor CP."  (nth 0 cp))
(defun getEnteredFromCommandDescription  (cp) "Get the entered command from the running command descriptor CP." (nth 1 cp))
(defun getSplitFromCommandDescription    (cp) "Get the entered command as a list from the running command descriptor CP." (nth 2 cp))
(defun getCommandHashEntry               (cp) "Get the command hash entry from the running command descriptor CP." (nth 3 cp))

#+END_SRC

*** Run a command

Commands run one at a time, that is, a new command is not started until the
previous command has finished. The command which is currently running is kept in
the variable jbug-runningCommand (more exactly, the list entry created by
describeRunnableCommand for that command is kept in jbug-runningCommand). If
jbug-runningCommand is not nil, then the java proxy is busy and we don't send a new
command.

#+BEGIN_SRC emacs-lisp :tangle jbug.el
(defvar jbug-runningCommand   () "The command the debugger is running now.")
#+END_SRC

The JAVA proxy signals that it is ready for a new command by sending a
COMMAND_READY_RESPONSE message. That message causes this program to do two
things:

 1. set jbug-runningCommand to nil
 2. check for queued commands and run the first on the queue

The command synchronisation mechanism is pretty simple.

Two preconditions must be met before a command is sent to the proxy:

1. jbug-runningCommand is nil
2. a command is available in the jbug-commandsToRun list (jbug-commandsToRun is not null).

Whenever one of those preconditions changes we call jbug-execute-command
which checks both. If both hold, we run the command.

All sorts of things are involved in executing a command:

1. the command is put into it's final form, in other words, all defaults get
   added. Note that this is done at the last minute so the defaults might
   have changed from when the command was entered. The work is done
   by a method contained in the command's hashMapEntry which is an
   entry in the list created by jbug-describeRunnableCommand which
   list is the element we took off the front of jbug-commandsToRun and placed into
   jbug-runningCommand.

2. the command (as an ascii string) goes into the command history,

3. the command is written to output,

4. the command is placed in jbug-runningCommand,

5. we run the function contained in the doCommand field of the command's
   commandHashEntry. This usually sends the command to the proxy.

#+BEGIN_SRC emacs-lisp :tangle jbug.el
(defun jbug-execute-command ()
  "If no command is presently running and there are commands
waiting to execute, run the first command on the jbug-commandsToRun
list."
  (when (and jbug-commandsToRun (not jbug-runningCommand))
    (setq jbug-runningCommand (car jbug-commandsToRun))
    (setq jbug-commandsToRun (cdr jbug-commandsToRun))
    (writeStringToBuffer jbug-proxyProcess (concat "\n*** " (getEnteredFromCommandDescription jbug-runningCommand) "\n"))
    (jbug-doCommand
     (getCommandHashEntry jbug-runningCommand)
     jbug-proxyProcess
     (getSplitFromCommandDescription jbug-runningCommand))))
#+END_SRC

** Responses from the proxy

The proxy sends message to this elisp program by writing them to its
stdout. EMACS receives the messages on stdin and passes them to this elisp
program by calling the insertion filter jbug-insertion-filter.

*** Responses

A response is an ascii string  terminated by a new line.

The tokens in a response are seperated by commas.

A response function is an elisp function that runs when this program receives
a response.

The first token in a response identifies the response type. The first token is
used as the key in a hash table lookup. The lookup returns an appropriate
response function.

There can be multiple hash tables containing response functions. We keep them in
a list (jbug-responseTables) and execute the function contained in each. The
list can change during execution; that is how we program the debugger.

#+BEGIN_SRC emacs-lisp :tangle jbug.el
(defvar
  jbug-responseTables
  ()
  "list of hash tables each of which contains response functions")

(defun jbug-getResponseTableName (env)
  (or (ht-get env "jbug-name") "unnamed environment"))

(defun jbug-addResponseTable  (name env)
  (cond ((s-blank? name)    (message "Tried to add response table with blank name"))
        ((null env)     (message "Tried to add a null response"))
        ((member env jbug-responseTables)
         (message "Tried to add duplicate response table (%s) to jbug-responseTables" name))
        (t              (progn
                          (ht-set env "jbug-name" name)
                          (push env jbug-responseTables)))))

(defun jbug-removeResponseTable (env)
  (if (not (member env jbug-responseTables))
      (message
       "Tried to remove a response table (%s) not contained in jbug-responseTables"
       (jbug-getResponseTableName env))
    (setq jbug-responseTables (-remove-item env jbug-responseTables))))

#+END_SRC

A set of response functions are defined below.

*** Receive a Response

The proxy sends data to this elisp program through stdout. That data is
manifested to this program when EMACS calls the following routine without
warning. The routine can return a response in pieces so we have to buffer
the string returned. A response is ended by a new line.

When we get a response, we split it on the commas and use the first field to
look up the response's entry in the jbug-response-hash-table hash map. If the
entry exists, it is a function which we execute with a funcall. Then we clean up
the output buffer.

#+BEGIN_SRC emacs-lisp :tangle jbug.el

(defvar jbug-responseCommands ())

(defun jbug-addResponseCommand (s)
       (setq jbug-responseCommands (cons s jbug-responseCommands)))

(defun jbug-insertion-filter (proc string)
  "Receive input from the proxy process.
PROC is the proxy process
STRING is the input from the proxy"
  (message "Received: %s :EndReceived" string)
  (if (not (eq jbug-proxyProcess proc))
      (message "Error: expected proxy %s got proxy %s" jbug-proxyProcess proc))
  (setq jbug-receivedFromProxy (concat jbug-receivedFromProxy string))

  (let ((com (split-string jbug-receivedFromProxy "\n" 't)))

    (if (s-ends-with? "\n" string)
        (setq jbug-receivedFromProxy ())
      (setq jbug-receivedFromProxy (-last-item com))
      (setq com                                    (-butlast com)))

    (dolist (c com)
      (when (not (s-blank? c))
          (let ((response (mapcar 's-trim (split-string c ","))))
            (mapc
             (lambda (env)
               (let ((ft (ht-get env (car response))))
                 (when  ft
                   ;; well, who knows what came back
                   (condition-case err
                       (funcall ft env response)
                     (error
                      (message
                       "Error in a response hook %s response: %s environment %s."
                       (error-message-string err)
                       c
                       (jbug-getResponseTableName env)))))))
             jbug-responseTables)

            (when (string= (car response) jbug-command-ready-response)
              (setq jbug-runningCommand ())))

          (jbug-fix-output-buffer proc)))

    ; check if it's time to execute a waiting command
    ; sometimes responses will queue commands to be executed. Add them
    ; to the waiting queue when everything has calmed down.

    (when (not jbug-receivedFromProxy)
      (if (not jbug-responseCommands)
          (jbug-execute-command)
        (let ((coms (s-join ";" (reverse jbug-responseCommands))))
          (setq jbug-responseCommands ())
          (goto-char (point-max))
          (insert (format "\n%s" coms))
          (jbug-newline))))))

;; make the output buffer right
(defun jbug-fix-output-buffer (proc)
  "Put point at the end of the jbug buffer, if it exists.
PROC is the proxy process."
  (when (and (buffer-live-p (process-buffer proc))
             (get-buffer-window (process-buffer proc)))
    (select-window (get-buffer-window (process-buffer proc)))
    (goto-char (point-max))
(if (not jbug-commandsToRun) (insert "\n-> "))))
#+END_SRC

** Output

The debugger outputs its results by writing them to the process buffer created
when it started. The buffer is an ORG mode buffer.

#+BEGIN_SRC emacs-lisp :tangle jbug.el

(defvar jbug-sourceDirectory nil "Root directory of the sources for the target JAVA program.")
(defconst jbug-orgTableSeperator    "|----|\n"   "String to seperate table title from contents.")

(defun writeStringToBuffer (proc string)
  "Write a string to the bottom of the jbug buffer.
PROC - the proxy process
STRING - the string to write in the buffer"
  (when (buffer-live-p (process-buffer proc))
    (with-current-buffer (process-buffer proc)
      (save-excursion
        (goto-char (point-max))
        (beginning-of-line)
        (insert string)))))

  (defun writeOrgTableToBuffer (proc title sep rows)
    (when (buffer-live-p (process-buffer proc))
      (with-current-buffer (process-buffer proc)
        (save-excursion
          ;; Insert the text, advancing the process marker.
          (goto-char (point-max))
          (insert (concat "\n\n" title))
          (let ((tableStart (point)))
            (insert sep)
            (insert (dataLayout rows))
            (goto-char tableStart)
            (ignore-errors (org-ctrl-c-ctrl-c)))))))

  (defun dataLayout (args)
    (if args
        (let ((s "| ")
              (stack ())
              (rc 0)
              (ac 0))
          (push (list rc args) stack)
          (while stack
            (cond
             ((not args)
              (let ((a (pop stack)))
                (setq args (nth 1 a))
                (setq rc     (nth 0 a))))
             ((listp (car args))
              (push (list rc (cdr args)) stack)
              (setq args (car args)))
             ((not (listp (car args)))
              (let ((v (car args)))
                (setq args (cdr args))
                (while (/= rc ac)
                  (cond
                   ((< ac rc)
                    (setq s (concat s " | "))
                    (setq ac (1+ ac)))
                   ((> ac rc)
                    (setq s (concat s "\n| "))
                    (setq ac 0))))
                (setq s (concat s v))
                (setq rc (1+ rc))))))
          s)
      ""))

(defun reportBreak (preface thread location)
  "Insert the desciption of a breakpoint into the jbug buffer.
PREFACE - a breakpoint or a step
THREAD - the thread in which the breakpoint occured
LOCATION - the location of the breakpoint"
  (setq jbug-defaultThread (threadID thread))
  (setq jbug-defaultFrame 0)
  (writeStringToBuffer
   jbug-proxyProcess
   (concat
    "** "
    preface
    " in thread "
    (threadID thread)
    " frame "
    (number-to-string jbug-defaultFrame)
    " at "
    (locationFile location)
    ":"
    (locationLineNumber location)
    " ("
    (if (locationMethod location) (locationMethod location) "")
    ")\n"))
  (setSourceFileWindow
   jbug-proxyProcess
   (locationFile location)
   (locationLineNumber location)))

(defun threadID               (args) "Get id from thread descriptor list ARGS."                       (nth 0 args))
(defun threadName          (args) "Get name from thread descriptor list ARGS."                   (nth 1 args))
(defun threadState           (args) "Get state from thread descriptor list ARGS."                   (nth 2 args))
(defun threadFrames        (args) "Get frame count  from thread descriptor list ARGS."          (nth 3 args))
(defun threadBreakpoint   (args) "Is thread at breakpoint from thread descriptor list ARGS."  (nth 4 args))
(defun threadSuspended   (args) "Is thread suspended  from thread descriptor list ARGS."    (nth 5 args))

(defun locationFile             (args) "Get file name from location descriptor list ARGS."        (nth 0 args))
(defun locationLineNumber (args) "Get line number from location descriptor list ARGS."     (nth 1 args))
(defun locationMethod       (args) "Get method name from location descriptor list ARGS."  (nth 2 args))

#+END_SRC

*** Set windows

We would really like two windows. One with the source file in it, the cursor on
the current line, a bookmark on that line, and that line in the middle of the
window. The other showing the org file with the cursor on the last line. Maybe
we can get this, maybe not.

#+BEGIN_SRC emacs-lisp :tangle jbug.el
(defun setSourceFileWindow (proc file line)
"Display the source file in the source file window.
PROC - proxy process
FILE   - source file
LINE  - current line in source file"
;; (message (format "setsourcewindow %s | %s | %s\n" jbug-sourceDirectory file (concat jbug-sourceDirectory file)))
  (let ((bug (find-file-noselect (concat jbug-sourceDirectory file))))
    (when (and bug (buffer-live-p (process-buffer proc)))
      (if (= (length (window-list)) 1)
          (split-window))
      (let ((source (winForOtherBuffer bug (process-buffer proc))))
        (if source
            (select-window source)
          (set-buffer bug))
        (goto-char (point-min))
        (forward-line (1- (string-to-number line)))
        (bm-remove-all-all-buffers)
        (bm-toggle)
        (if (eq (window-buffer) bug) (recenter-top-bottom)))
      (let ((procWin (winForOtherBuffer (process-buffer proc) bug)))
        (if procWin
            (select-window procWin)
          (set-buffer (process-buffer proc)))
        (goto-char (point-max))))))

(defun winForOtherBuffer (buffer notbuffer)
  (let ((win (get-buffer-window buffer)))
    (when (not win)
      (let  ((wl (window-list)))
        (while (and wl (eq notbuffer (window-buffer (car wl))))
          (setq wl (cdr wl)))
        (setq win (if wl (car wl) (car (window-list))))
        (set-window-buffer win buffer)))
    win))
#+END_SRC

** Commands and Responses
*** Responses

#+BEGIN_SRC emacs-lisp :tangle jbug.el#+BEGIN_SRC emacs-lisp :tangle jbug.el
(defconst jbug-accessWatchpoint-response "accesswatchpoint" "Keyword identifying response string from buffer.")
(defconst jbug-accessWatchpointSet-response "accesswatchpointset" "Keyword identifying response string from buffer.")
(defconst jbug-arguments-response "arguments" "Keyword identifying response string from buffer.")
(defconst jbug-breakpointCleared-response "breakpointcleared" "Keyword identifying response string from buffer.")
(defconst jbug-breakpointCreated-response "breakpointcreated" "Keyword identifying response string from buffer.")
(defconst jbug-breakpointEntered-response "breakpointentered" "Keyword identifying response string from buffer.")
(defconst jbug-breakpointList-response "breakpointlist" "Keyword identifying response string from buffer.")
(defconst jbug-catchEnabled-response "catchenabled" "Keyword identifying response string from buffer.")
(defconst jbug-classPrepared-response "classprepared" "Keyword identifying response string from buffer.")
(defconst jbug-classUnloaded-response "classunloaded" "Keyword identifying response string from buffer.")
(defconst jbug-classes-response "classes" "Keyword identifying response string from buffer.")
(defconst jbug-command-ready-response "commandready" "JAVA proxy is ready to receive a command.")
(defconst jbug-error-response "error" "Keyword identifying response string from buffer.")
(defconst jbug-exception-response "exception" "Keyword identifying response string from buffer.")
(defconst jbug-fields-response "fields" "Keyword identifying response string from buffer.")
(defconst jbug-internalException-response "internalexception" "Keyword identifying response string from buffer.")
(defconst jbug-locals-response "locals" "Keyword identifying response string from buffer.")
(defconst jbug-log-response "log" "Keyword identifying response string from buffer.")
(defconst jbug-modificationWatchpoint-response "modificationwatchpoint" "Keyword identifying response string from buffer.")
(defconst jbug-modificationWatchpointSet-response "modificationwatchpointset" "Keyword identifying response string from buffer.")
(defconst jbug-preparingClass-response "preparingclass" "Keyword identifying response string from buffer.")
(defconst jbug-proxyExited-response "proxyexited" "Keyword identifying response string from buffer.")
(defconst jbug-proxyStarted-response "proxystarted" "Keyword identifying response string from buffer.")
(defconst jbug-stack-response "stack" "Keyword identifying response string from buffer.")
(defconst jbug-step-response "step" "Keyword identifying response string from buffer.")
(defconst jbug-stepCreated-response "stepcreated" "Keyword identifying response string from buffer.")
(defconst jbug-this-response "this" "Keyword identifying response string from buffer.")
(defconst jbug-threadDied-response "threaddied" "Keyword identifying response string from buffer.")
(defconst jbug-threadList-response "threadlist" "Keyword identifying response string from buffer.")
(defconst jbug-threadStarted-response "threadstarted" "Keyword identifying response string from buffer.")
(defconst jbug-vmCreated-response "vmcreated" "Keyword identifying response string from buffer.")
(defconst jbug-vmDied-response "vmdied" "Keyword identifying response string from buffer.")
(defconst jbug-vmDisconnected-response "vmdisconnected" "Keyword identifying response string from buffer.")
(defconst jbug-vmResumed-response "vmresumed" "Keyword identifying response string from buffer.")
(defconst jbug-vmStarted-response "vmstarted" "Keyword identifying response string from buffer.")

(defun jbug-initializeResponseTables ()

  (setq jbug-responseTables ())

  (jbug-addResponseTable
   "base environment"
   (ht

    (jbug-accessWatchpointSet-response
     `(lambda (env response)
        (let ((class  (nth 1 response))
              (field (nth 2 response)))
          (writeStringToBuffer
           proc
           (concat
            "Access watchpoint set for field "
            field
            " in class " class ".\n"))))
)

    (jbug-accessWatchpoint-response
     `(lambda (env response)
        (let ((tr                  (-slice response 1 7))
              (loc               (-slice response 7))
              (className (nth 10 response))
              (fieldName  (nth 11 response))
              (value          (nth 0 (read-from-string (nth 12 response)))))
          (reportBreak (concat "Access watchpoint  entered") tr loc)
          (writeOrgTableToBuffer
           jbug-proxyProcess
           "|Class:Field|Value|\n"
           jbug-orgTableSeperator
           (list (concat className ":" fieldName) (list "current" value))))))


    (jbug-arguments-response
     `(lambda (env response)
        (let
            ((thread (nth 1 response))
             (frame (nth 2 response))
             (th (nth 0 (read-from-string (nth 3 response)))))
          (writeStringToBuffer
           jbug-proxyProcess
           (format "Arguments for thread %s frame number %s.\n" thread frame))
          (writeOrgTableToBuffer
           jbug-proxyProcess
           "| Name | Value |\n"
           jbug-orgTableSeperator
           th))))


    (jbug-breakpointCleared-response
     `(lambda (env response)
        (jbug-display-breakpoints((mapcar
                                   (lambda (x)
                                     (list
                                      (car x)
                                      (-slice x 1)))
                                   (-partition-in-steps 4 4 (-slice response  1)))))))


    (jbug-breakpointCreated-response
     `(lambda (env response)
        (let
            (( breakId (nth 1 response))
             (loc          (-slice response 2 5)))
          (writeStringToBuffer proc (concat "Breakpoint  " breakId " created at " (jbug-LocationString loc)  ".\n")))))


    (jbug-breakpointEntered-response
     `(lambda (env response)
        (let
            ((breakId  (nth 1 response))
             (tr             (-slice response 2 8))
             (loc          (-slice response 8)))
          (reportBreak (concat "Breakpoint " breakId " entered") tr loc))))


    (jbug-breakpointList-response
     `(lambda (env response)
        (jbug-display-breakpoints
         (mapcar
          (lambda (x)
            (list
             (car x)
             (-slice x 1)))
          (-partition-in-steps 4 4 (-slice response  1))))))


    (jbug-catchEnabled-response
     `(lambda (env response)
        (writeStringToBuffer
         proc
         (format "Exceptions %s\n" (if (string= (nth 1 response) "true") "enabled" "disabled")))))


    (jbug-classPrepared-response
     `(lambda (env response)
        (writeStringToBuffer proc (concat  (s-join " " response) ".\n"))))


    (jbug-classUnloaded-response
     `(lambda (env response)
        `t))


    (jbug-classes-response
     `(lambda (env response)
        (let
            ((classes (-slice response 1)))
          (writeStringToBuffer
           proc
           "classes\n")
          (dolist (r classes)
            (writeStringToBuffer
             proc
             (format "%s\n" r))))))


    (jbug-error-response
     `(lambda (env response)
        (writeStringToBuffer proc (concat "Error: "  (nth 1 response) "\n"))))


    (jbug-exception-response
     `(lambda (env response)
        (let
            ((name (nth 1 response))
             (loc (-slice response 2 5))
             (message (nth 5 response))
             (stack (nth 0 (read-from-string (nth 6 response)))))
          (writeStringToBuffer
           proc
           (concat
            name " occured in target at " (jbug-LocationString loc) "\nMessage: " message "\nStack Trace:\n"))
          (let ((c (mapcar (lambda (x) (-slice (assoc "fields" x) 1))  (-slice (assoc "contents"  stack) 1))))
            (-each
                (-partition 3
                            (-interleave
                             (mapcar (lambda (x) (nth 1 (assoc "fileName" x))) c)
                             (mapcar (lambda (x) (nth 1 (assoc "lineNumber" x))) c)
                             (mapcar (lambda (x) (nth 1 (assoc "methodName" x))) c)))
              (lambda (x) (writeStringToBuffer proc (format " %s\n" (jbug-LocationString x)))))))))


    (jbug-fields-response
     `(lambda (env response)
        (let
            ((className  (nth 1 response))
             (fields (-partition-in-steps 8 8 (-slice response 2))))
          (writeStringToBuffer jbug-proxyProcess (concat "Fields for class: " className "\n"))
          (writeOrgTableToBuffer
           jbug-proxyProcess
           "|Field |Type|Declaring Type|Enum|Transient|Volatile|Final|Static|\n"
           jbug-orgTableSeperator
           fields))))


    (jbug-internalException-response
     `(lambda (env response)
        (let
            ((msg (nth  1 response))
             (stack (nth 2 response)))
          (writeStringToBuffer proc (concat "Internal exception in proxy: " msg "\n" stack "\n")))))


    (jbug-locals-response
     `(lambda (env response)
        (let
            ((thread   (nth 1 response))
             (frame    (nth 2 response))
             (th           (nth 0 (read-from-string (nth 3 response)))))
          (writeStringToBuffer
           jbug-proxyProcess
           (format "Locals for thread %s frame number %s.\n" thread frame))
          (writeOrgTableToBuffer
           jbug-proxyProcess
           "| Name | Value |\n"
           jbug-orgTableSeperator
           th))))


    (jbug-log-response
     `(lambda (env response)
        (writeStringToBuffer proc (concat (nth 1 response) ".\n"))))


    (jbug-modificationWatchpoint-response
     `(lambda (env response)
        (let ((tr                 (-slice response 1 7))
              (loc                 (-slice response 7))
              (className (nth 10 response))
              (fieldName  (nth 11 response))
              (old                (nth 0 (read-from-string (nth 12 response))))
             (new              (nth 0 (read-from-string (nth 13 response)))))
          (reportBreak (concat "Modification watchpoint  entered") tr loc)
          (writeOrgTableToBuffer
           jbug-proxyProcess
           "|Class:Field|Value|\n"
           jbug-orgTableSeperator
           (list (concat className ":" fieldName) (list "current" old) (list "new" new))))))


    (jbug-modificationWatchpointSet-response
     `(lambda (env response)
        (let ((class  (nth 1 response))
              (field (nth 2 response)))
        (writeStringToBuffer
         proc
         (concat
          "Modification watchpoint set for field "
          field
          " in class " class ".\n")))))


    (jbug-preparingClass-response
     `(lambda (env response)
        (writeStringToBuffer proc (concat "Preparing class " (nth 1 response) ".\n"))))


    (jbug-proxyExited-response
     `(lambda (env response)
        (writeStringToBuffer jbug-proxyProcess "Debugger proxy exited\n")
        (delete-process jbug-proxyProcess)))


    (jbug-proxyStarted-response
     `(lambda (env response)
        (writeStringToBuffer jbug-proxyProcess "Debugger proxy started\n")))


    (jbug-stack-response
     `(lambda (env response)
        (let
            ((id (nth 1 response))
             (locations  (-partition-in-steps 3 3 (-slice response 2))))
          (writeStringToBuffer jbug-proxyProcess (concat "Stack for thread " id " \n"))
          (if  (>=  jbug-defaultFrame (length locations))
              (setq jbug-defaultFrame (1- (length locations))))
          (writeOrgTableToBuffer
           jbug-proxyProcess
           "||Frame|File|Line|Method|\n"
           jbug-orgTableSeperator
           (let ((ff ())
                 (locs locations))
             (dotimes (i (length locs))
               (setq ff
                     (cons
                      (cons
                       (if (= i jbug-defaultFrame) "*" "")
                       (cons
                        (number-to-string i)
                        (nth i locs)))
                      ff)))
             (reverse ff)))
          (when (< jbug-defaultFrame (length locations))
            (let ((loc (nth jbug-defaultFrame locations)))
              (setSourceFileWindow
               jbug-proxyProcess
               (locationFile loc)
               (locationLineNumber loc)))))))


    (jbug-step-response
     `(lambda (env response)
        (let
            ((tr   (-slice response 1 7))
             (loc (-slice response 7)))
          (reportBreak "step" tr loc))))


    (jbug-this-response
     `(lambda (env response)
        (let
            (( thread (nth 1 response))
             (frame (nth 2 response))
             (th (nth 0 (read-from-string (nth 3 response)))))
          (writeStringToBuffer
           jbug-proxyProcess
           (format "This for thread %s frame number %s.\n" thread frame))
          (writeOrgTableToBuffer
           jbug-proxyProcess
           "|This|\n"
           jbug-orgTableSeperator
           th))))


    (jbug-threadDied-response
     `(lambda (env response)
        `t))

    (jbug-threadList-response
     `(lambda (env response)
        (let
            ((threads (-partition-in-steps 6 6 (-slice response 1))))
          (writeOrgTableToBuffer
           jbug-proxyProcess
           "|ID|Name|State|Frames|Breakpoint|Suspended|\n"
           jbug-orgTableSeperator
           threads))))


    (jbug-threadStarted-response
     `(lambda (env response)
        `t))

    (jbug-vmCreated-response
     `(lambda (env response)
        (writeStringToBuffer jbug-proxyProcess "virtual machine created\n")))


    (jbug-vmDied-response
     `(lambda (env response)
        (writeStringToBuffer jbug-proxyProcess "virtual machine terminated\n")
        (jbug-addResponseCommand "quit")))


    (jbug-vmDisconnected-response
     `(lambda (env response)
        (writeStringToBuffer jbug-proxyProcess "virtual machine disconnected\n")
        (jbug-addResponseCommand "quit")))


    (jbug-vmResumed-response
     `(lambda (env response)
        (writeStringToBuffer jbug-proxyProcess "virtual machine resuming operation.\n")))


    (jbug-vmStarted-response
     `(lambda (env response)
        (writeStringToBuffer jbug-proxyProcess "virtual machine started\n")))
    )))


(defun jbug-display-breakpoints (breakpoints)
  (writeStringToBuffer
   jbug-proxyProcess
   "Breakpoints")
  (writeOrgTableToBuffer
   jbug-proxyProcess
   "|id|location|\n"
   jbug-orgTableSeperator
   (mapcar
    (lambda (x)
      (list
       (nth 0 x)
       (concat (nth 0 (nth 1 x)) ":" (nth 1 (nth 1 x)))))
    breakpoints)))

#+END_SRC

*** Commands
**** access

Set an access watchpoint.

Request for notification when the contents of a field are accessed in the target
VM. This event will be triggered when the specified field is accessed by Java
programming language code or by a Java Native Interface (JNI) get function.

#+BEGIN_SRC emacs-lisp :tangle jbug.el

(ht-set
 jbug-commandHashMap
 "access"
 (jbug-makeCommandHashEntry
  "access"
  (lambda (c) (/= (length c) 3))
  "access class-name field-name"
  (lambda (proxy c)
    (process-send-string
     proxy
     (format
      "access,%s,%s\n"
      (nth 1 c)
      (nth 2 c))))))

#+END_SRC

**** arguments

Print the arguments to a method.

By default prints all local variables but can specify the variables to print
with a variable descriptor string.

#+BEGIN_SRC emacs-lisp :tangle jbug.el

(ht-set
 jbug-commandHashMap
 "arguments"
 (jbug-makeCommandHashEntry
  "arguments"
  (lambda (c) (or (< (length c) 1) (> (length c) 4)))
  "arguments  [variable names] [thread] [frame]"
  (lambda (proxy c)
    (process-send-string
     proxy
     (jbug-dots c)))))

#+END_SRC

**** attach

Attach the debugger to the target VM.

#+BEGIN_SRC emacs-lisp :tangle jbug.el

(ht-set
 jbug-commandHashMap
 "attach"
   (jbug-makeCommandHashEntry
    "attach"
    (lambda (c) (or (/= (length c) 3)  (not (string-match "[0-9]+" (nth 2 c)))))
    "attach host  [port number ]"
    (lambda (proxy c)
      (process-send-string
       proxy
       (format "attach,%s,%s\n" (nth 1 c) (nth 2 c))))))
#+END_SRC

**** break

Set a breakpoint in the target VM.

#+BEGIN_SRC emacs-lisp :tangle jbug.el

(ht-set
 jbug-commandHashMap
 "break"
 (jbug-makeCommandHashEntry
  "break"
  (lambda (c) (/= (length c) 3))
  "break class-name <line-number|method name>"
  (lambda (proxy c)
    (process-send-string
     proxy
     (format "break,%s,%s\n" (nth 1 c) (nth 2 c))))))

#+END_SRC

**** breaks

List breakpoints enabled in the target VM.

#+BEGIN_SRC emacs-lisp :tangle jbug.el

(ht-set
 jbug-commandHashMap
 "breaks"
   (jbug-makeCommandHashEntry "breaks"
                                   (lambda (c) (/= (length c) 1))
                                   "breaks"
                                   (lambda (proxy _c)
                                     (process-send-string
                                      proxy
                                      "breaks\n"))))

#+END_SRC
**** catch

Request notification when an exception occurs in the target VM.

#+BEGIN_SRC emacs-lisp :tangle jbug.el

(ht-set
 jbug-commandHashMap
 "catch"
   (jbug-makeCommandHashEntry
    "catch"
    (lambda (c) (or (/= (length c) 2)  (and (not (string-match "on" (nth 1 c))) (not (string-match "off" (nth 1 c))))))
    "catch on|off"
    (lambda (proxy c)
      (process-send-string
       proxy
       (format
        "catch,%s\n"
        (nth 1 c))))))

#+END_SRC

**** classes

Print all classes loaded in the target VM.

#+BEGIN_SRC emacs-lisp :tangle jbug.el

(ht-set
 jbug-commandHashMap
 "classes"
   (jbug-makeCommandHashEntry
    "classes"
    (lambda (c) (/= (length c) 1))
    "classes"
    (lambda (proxy _c)
      (process-send-string
       proxy
       "classes\n"))))

#+END_SRC
**** clear

Clear all breakpoints or the specified breakpoint.

#+BEGIN_SRC emacs-lisp :tangle jbug.el

(ht-set
 jbug-commandHashMap
 "clear"
   (jbug-makeCommandHashEntry
    "clear"
    (lambda (c)
      (or (/= (length c) 2)
          (and
           (not (string-match "[0-9]+" (nth 1 c)))
           (not (string= "all" (nth 1 c))))))
    "clear [breakpoint-id/all]"
    (lambda (proxy c)
      (process-send-string
       proxy
       (format
        "clear,%s\n"
        (nth 1 c))))))

#+END_SRC
**** down

Set the default frame to the frame directly below the current default frame.

#+BEGIN_SRC emacs-lisp :tangle jbug.el

(ht-set
 jbug-commandHashMap
 "down"
   (jbug-makeCommandHashEntry "down"
                              (lambda (c) (and (/= (length c) 1) (/= (length c) 2)))
                               "down"
                               (lambda (proxy c)
                                 (setq jbug-defaultFrame (1+ jbug-defaultFrame))
                                 (process-send-string
                                  proxy
                                  (format
                                   "stack,%s\n"
                                   (if (= 1 (length c)) jbug-defaultThread (nth 1 c)))))))
#+END_SRC

**** fields

Prints all the fields of a given class.

#+BEGIN_SRC emacs-lisp :tangle jbug.el

(ht-set
 jbug-commandHashMap
 "fields"
   (jbug-makeCommandHashEntry "fields"
                               (lambda (c) (/= (length c) 2))
                               "fields"
                               (lambda (proxy c)
                                 (process-send-string
                                  proxy
                                  (format "fields,%s\n" (nth 1 c))))))

#+END_SRC

**** help

Prints a short description of every debugger command.

#+BEGIN_SRC emacs-lisp :tangle jbug.el

(ht-set
 jbug-commandHashMap
 "help"
   (jbug-makeCommandHashEntry "help"
                               (lambda (_c) ())
                               "help"
                               (lambda (proxy _c)
                                 (dolist (v
                                          (sort (ht-map (lambda (_key value) (jbug-hashDescribeCommand value)) jbug-commandHashMap) 'string<))
                                  (writeStringToBuffer proxy (concat v "\n")))
                                 (setq jbug-runningCommand ())
                                 (jbug-fix-output-buffer jbug-proxyProcess))))

#+END_SRC

**** locals

Print local variables with their values.

By default prints all local variables but can specify the variables to print
with a variable descriptor string.

#+BEGIN_SRC emacs-lisp :tangle jbug.el

(ht-set
 jbug-commandHashMap
 "locals"
 (jbug-makeCommandHashEntry
  "locals"
  (lambda (c) (or (< (length c) 1) (> (length c) 4)))
  "locals  [variable names] [thread] [frame]"
  (lambda (proxy c)
    (process-send-string
     proxy
     (jbug-dots c)))))

#+END_SRC

**** back, into, next

Execute a single step in the target VM.

back - step out of the current frame
into - step to the next location on a different line or into a new frame,
next - step to the next location on a different line and over a new frame.

#+BEGIN_SRC emacs-lisp :tangle jbug.el

(ht-set
 jbug-commandHashMap
 "back"
   (jbug-makeCommandHashEntry "back"
                               (lambda (c) (or (> (length c) 2)  (and (= (length c) 2) (not (string-match "[0-9]+" (nth 1 c))))))
                               "back [thread-id]"
                               (lambda (proxy c)
                                 (process-send-string
                                  proxy
                                  (format
                                   "back,%s\n"
                                   (if (= (length c) 1) jbug-defaultThread (nth 1 c)))))))

(ht-set
 jbug-commandHashMap
 "into"
   (jbug-makeCommandHashEntry "into"
                               (lambda (c) (or (> (length c) 2)  (and (= (length c) 2) (not (string-match "[0-9]+" (nth 1 c))))))
                               "into [thread-id]"
                               (lambda (proxy c)
                                 (process-send-string
                                  proxy
                                  (format
                                   "into,%s\n"
                                   (if (= (length c) 1) jbug-defaultThread (nth 1 c)))))))

(ht-set
 jbug-commandHashMap
 "next"
   (jbug-makeCommandHashEntry "next"
                               (lambda (c) (or (> (length c) 2)  (and (= (length c) 2) (not (string-match "[0-9]+" (nth 1 c))))))
                               "next [thread-id]"
                               (lambda (proxy c)
                                 (process-send-string
                                  proxy
                                  (format
                                   "next,%s\n"
                                   (if (= (length c) 1) jbug-defaultThread (nth 1 c)))))))

#+END_SRC

**** modify

Set a modification watchpoint.

Request notification when a field is set. This event will be triggered when a
value is assigned to the specified field with a Javatatement (assignment,
increment, etc) or by a Java Native Interface (JNI) set function Setting a field
to a value which is the same as the previous value still triggers this event.

#+BEGIN_SRC emacs-lisp :tangle jbug.el

(ht-set
 jbug-commandHashMap
 "modify"
   (jbug-makeCommandHashEntry "modify"
                               (lambda (c) (/= (length c) 3))
                               "modify class-name field-name"
                                (lambda (proxy c)
                                 (process-send-string
                                  proxy
                                  (format
                                  "modify,%s,%s\n"
                                   (nth 1 c)
                                   (nth 2 c))))))

#+END_SRC

**** prepare

Request notification when a class is prepared in the target VM.

#+BEGIN_SRC emacs-lisp :tangle jbug.el

(ht-set
 jbug-commandHashMap
 "prepare"
   (jbug-makeCommandHashEntry "prepare"
                               (lambda (c) (/= (length c) 2))
                               "prepare [class name]"
                               (lambda (proxy c)
                                 (process-send-string
                                  proxy
                                  (format "prepare,%s\n" (nth 1 c))))))

#+END_SRC

**** quit

End the debugging session.

#+BEGIN_SRC emacs-lisp :tangle jbug.el

(ht-set
 jbug-commandHashMap
 "quit"
   (jbug-makeCommandHashEntry "quit"
                               (lambda (c) (/= (length c) 1))
                               "quit"
                               (lambda (proxy _c)
                                 (process-send-string
                                  proxy
                                  "quit\n"))))

#+END_SRC

**** run

Start or resume program execution.

#+BEGIN_SRC emacs-lisp :tangle jbug.el

(ht-set
 jbug-commandHashMap
 "run"
   (jbug-makeCommandHashEntry "run"
                               (lambda (c) (/= (length c) 1))
                               "run"
                               (lambda (proxy _c)
                                 (process-send-string
                                  proxy
                                  "run\n"))))

(ht-set
 jbug-commandHashMap
 "continue"
   (jbug-makeCommandHashEntry "continue"
                               (lambda (c) (/= (length c) 1))
                               "continue"
                               (lambda (proxy _c)
                                 (process-send-string
                                  proxy
                                  "run\n"))))

#+END_SRC

**** set

Set the jbug-defaultThread which will be used by future commands. Use the 'threads'
command to get a list of threads and their ids.

#+BEGIN_SRC emacs-lisp :tangle jbug.el

(ht-set
 jbug-commandHashMap
 "set"
   (jbug-makeCommandHashEntry "set"
                               (lambda (c) (or (/= (length c) 2)  (not (string-match "[0-9]+" (nth 1 c)))))
                               "set [thread-id]"
                               (lambda (proxy c)
                                 (setq jbug-defaultThread (nth 1 c))
                                 (process-send-string
                                  proxy
                                  "threads\n"))))

#+END_SRC

**** stack

Print the stack of method calls which have brought us to this point.

#+BEGIN_SRC emacs-lisp :tangle jbug.el

(ht-set
 jbug-commandHashMap
 "stack"
   (jbug-makeCommandHashEntry "stack"
                               (lambda (c) (and (/= (length c) 1) (/= (length c) 2)))
                               "stack [thread]"
                               (lambda (proxy c)
                                 (process-send-string
                                  proxy
                                  (format
                                   "stack,%s\n"
                                   (if (= 1 (length c)) jbug-defaultThread (nth 1 c)))))))

#+END_SRC

**** this

Prints the object pointed to by the 'this' JAVA keyword in the default thread
and default frame.

#+BEGIN_SRC emacs-lisp :tangle jbug.el

(ht-set
 jbug-commandHashMap
 "this"
 (jbug-makeCommandHashEntry
  "this"
  (lambda (c) (or (< (length c) 1) (> (length c) 4)))
  "this  [variable names]  [thread]  [frame]"
  (lambda (proxy c)
    (process-send-string
     proxy
     (jbug-dots c)))))

#+END_SRC

**** threads

Prints the running threads and their status.

#+BEGIN_SRC emacs-lisp :tangle jbug.el

(ht-set
 jbug-commandHashMap
 "threads"
   (jbug-makeCommandHashEntry "threads"
                                   (lambda (c) (/= (length c) 1))
                                   "threads"
                                   (lambda (proxy _c)
                                     (process-send-string
                                      proxy
                                      "threads\n"))))

#+END_SRC

**** up

Decrement jbug-defaultFrame moving it closer to the current frame.

#+BEGIN_SRC emacs-lisp :tangle jbug.el

(ht-set
jbug-commandHashMap
 "up"
   (jbug-makeCommandHashEntry "up"
                              (lambda (_c) nil)
                               "up"
                               (lambda (proxy _c)
                                 (if (> jbug-defaultFrame 0)
                                   (setq jbug-defaultFrame (1- jbug-defaultFrame)))
                                 (process-send-string
                                  proxy
                                  (format
                                   "stack,%s\n"
                                   jbug-defaultThread)))))

#+END_SRC

*** Miscellaneous responses from the debugger proxy

#+BEGIN_SRC emacs-lisp :tangle jbug.el

(defun jbug-LocationString (l)
  "Return a string describing the location descriptor list L"
  (format "%s:%s %s" (locationFile l) (locationLineNumber l) (locationMethod l)))

(defun jbug-dots (c)
  (let ((a (concat (nth 0 c)  ",%s,%s,%s\n")))
    (cond
      ((= (length c) 1)
       (format a  jbug-defaultThread jbug-defaultFrame (setDotNotation "")))
      ((= (length c) 2)
       (format a jbug-defaultThread jbug-defaultFrame (setDotNotation (nth 1 c))))
      ((= (length c) 3)
       (format a (nth 2 c) jbug-defaultFrame (setDotNotation (nth 1 c))))
      ((= (length c) 4)
       (format a (nth 2 c) (nth 3 c)  (setDotNotation (nth 1 c)))))))

(defun setDotNotation(a)
"Put array string into dot notation for proxy."
  (setq a (s-trim a))
  (let ((b (if (string= a "") () (-take 6 (s-split "[.]" a)))))
    (while (< (length b) 6) (setq b (-snoc b "*")))
    (s-join "." b)))

#+END_SRC

** Start up

#+BEGIN_SRC emacs-lisp :noweb tangle :tangle jbug.el

;;;###autoload
(defun jbug  (src mn host port)
  "Start the debugger.
SRC - root of source tree
MN - main class of debugged program
HOST - host on which debugged program runs
PORT - port to which attach debugger"
    (interactive "Droot of source tree: \nMmain class: \nMhost: \nMport number: ")
    (message "startProc")
    (find-file (concat mn (format-time-string ".%Y,%m.%d.%H.%M.%S") ".org"))
    (insert "#+STARTUP: showeverything\n")
    (goto-char (point-max))
    (setq jbug-sourceDirectory (file-name-as-directory (expand-file-name src)))
    (insert
     (concat
      "\n\n* "
      "Starting debugger session " (current-time-string)
      ".\n\tSource directory: " jbug-sourceDirectory
      ".\n\tMain class: " mn
      ".\n\tHost: " host
      ".\n\tPort: "  port ".\n\n"));
    (delete-other-windows)
    (jbug-mode)

    ;; set up the response tables

    (jbug-initializeResponseTables)

    (jbug-addResponseTable
     "initialization environment"
      (ht
       (jbug-vmStarted-response
        `(lambda (env response)
           (jbug-addResponseCommand (format "catch on;prepare %s" (ht-get env "EXPECTED")))))
       (jbug-vmDied-response
        `(lambda (env response)
          (writeStringToBuffer jbug-proxyProcess "If the virtual machine terminates immediately perhaps the process to be debugged is not running.\n")))
        (jbug-classPrepared-response
        `(lambda (env response)
           (let ((expected (ht-get env "EXPECTED")))
             (when (string= expected (nth 1 response))

(jbug-addResponseCommand (format "break %s main;continue" expected))
               (jbug-removeResponseTable env)))))
     ("EXPECTED" mn)))

    (run-hooks `jbug-mode-hook)

    ;; start the proxy

    <<start-proxy>>

    ; initialization commands

    (goto-char (point-max))
    (set-marker (process-mark jbug-proxyProcess) (point))
    (insert (format "attach %s %s" host port))
    (jbug-newline))
#+END_SRC
** Provide

#+BEGIN_SRC emacs-lisp :tangle jbug.el

(provide 'jbug)
;;; jbug.el ends here
#+END_SRC
