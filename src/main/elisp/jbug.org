* Java Debugger
** Introduction

JbugMode is a replacement for the combination of the GUD/JDP emacs mode and
the Oracle command line debugger jdb. This combination will be refered to as jdb
in what follows.

JbugMode will seem familiar to anyone experienced with jdb. The commands
are similar and the overall feeling is that of a command line program with an
emacs mode as a front end.

Its overall design is also similar to jdb. There is an elisp program which
implements an emacs mode - in this case a minor mode called jbug-mode
derived from Org mode - and an proxy program written in JAVA which uses the JAVA
JDI interface to communicate with the program to be debugged and stdin/stdout to
communicate with the elisp program.

JbugMode has certain advantages over jdb. For one, it works. For another,
it is easy to install and configure. Also, JbugMode looks into variables;
for example, instead of displaying the number of bins in a hash table it will
show the key/value pairs in the table. It is easy to change or script the
debugger in elisp. And the debugging session is kept in an org buffer which can
be saved or exported as the user desires.

The debugger is basicly four command streams and the code to handle them.

The first command stream is the input from the user to the elisp program. The
commands are seperated by newlines and each command is a series of ASCII tokens
seperated by spaces. The first token in a line identifies the command and the
rest of the tokens are arguments to that command. The first token is used as the
key to a hash table (commandHashMap), the entry in the hash table describes the
action to be taken on receipt of the command.

The second command steam is output from the elisp program and read by the JAVA
proxy on its standard input. The commands are seperated by newlines, each
command is a series of ASCII tokens, seperated by commas. The first token names
the command and is the key to a hash table identifying the action to be taken on
receipt of the command. See the file JavaDebggerProxy.java.

The third command stream is a queue of objects signalling asynchronous
events. The stream is created by the JDI package and is read by an independent
thread which waits on the queue and dequeues the events in sequence. See
EventReader.java.

The fourth command is produced by the JAVA proxy in response to commands from
the elisp program and events from the JDI interface. The proxy writes this
stream to its standard out and the elisp program receives it. The stream
consists of commands seperated by newlines. Each command is a sequence of ASCII
tokens seperated by commas. The first token identifies the command and is the
key to a hash table (jbug-response-hash-table) in the elisp program which
describes the action to be taken on receipt of the command.

There is some code in the elisp to display data read from the debugger proxy and
some code in the debugger proxy to look inside of variables (DebuggerOutput.java).
That's about it.

** Boilerplate

#+BEGIN_SRC emacs-lisp :tangle jbug.el
;;; jbug.el --- An Emacs based JAVA debugger

;;; Copyright (C) 2010-2018 Jonathan Ruby

;; Author: Jonathan Ruby <jruby21@protonmail.com>
;; Maintainer: Jonathan Ruby <jruby21@protonmail.com>
;; Created: 18 August 2018
;; Keywords: tools
;; Homepage: https://github.com/jruby21/javadebugger

;; This file is not part of GNU Emacs.

;; This file is free software

;;    This file is part of jbug.

;;    jbug is free software: you can redistribute it and/or modify
;;    it under the terms of the GNU General Public License as published by
;;    the Free Software Foundation, either version 3 of the License, or
;;    (at your option) any later version.

;;    jbug is distributed in the hope that it will be useful,
;;    but WITHOUT ANY WARRANTY; without even the implied warranty of
;;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;;    GNU General Public License for more details.

;;    You should have received a copy of the GNU General Public License
;;    along with jbug.  If not, see <https://www.gnu.org/licenses/>.

;;; Commentary:

;;    For documentation of the code, see the org babel file 'jbug.org'
;;    available at https://github.com/jruby21/javadebugger/tree/master/src/main/elisp/jbug.orgp

;;; Code:

#+END_SRC

** Require

#+BEGIN_SRC emacs-lisp :tangle jbug.el

; jbugMode requires loading these four emacs packages:

;   bm
;   dash
;   ht
;   s

(require 'bm)
(require 'dash)
(require 'ht)
(require 's)

#+END_SRC

** jbug mode

The elisp program runs a mode name jbug-mode. The mode is derived from ORG
mode.

#+BEGIN_SRC emacs-lisp :tangle jbug.el

;;;###autoload
(defvar jbug-mode-map
  (let ((map (make-sparse-keymap)))
    (define-key map (kbd "RET") 'jbug-newline)
    (define-key map (kbd "M-p") 'jbug-previous-command-in-history)
    (define-key map (kbd "M-n") 'jbug-next-command-in-history)
    map))

;;;###autoload
(define-derived-mode jbug-mode
  org-mode "Jbug"
  "Major mode java debugger.")

(defvar defaultThread "1" "the last thread in which we had a breakpoint. use this thread if no thread number is specified in a command")
(defvar defaultFrame  0   "the frame we examined")

#+END_SRC

** The Proxy

There is a JAVA prgram called the 'proxy' which connects to the target process
and handles the JDI interface.  The proxy runs as a sub process to emacs. This
elisp program sends commands to the proxy on stdin and receives replies on
stdout.

#+BEGIN_SRC emacs-lisp :tangle jbug.el
(defvar proxyProcess () "the JAVA proxy program which connects to the program to be debugged")

(defcustom jbug-proxy
  "java -cp ~/jbug/src/main/java/com/github/jruby21/jbug/JbugProxy:~/jdk1.8.0_131/lib/tools.jar com.github.jruby21.jbug.JbugProxy"
  "full command to run jbug proxy"
  :type '(string)
  :group 'jbug)
#+END_SRC

*** Start the proxy

Start the proxy and set the filter which handles strings received on stdin from
the proxy.  There is a special debugger command (proxy) that does nothing but
wait for the proxy to signal that it has started.

#+BEGIN_SRC emacs-lisp :noweb-ref start-proxy

(setq commandsToRun ())

(setq runningCommand
      (jbug-describeRunnableCommand
       "proxy"
       "proxy"
       (list "proxy")
       (jbug-makeCommandHashEntry
        "proxy"
        (lambda (c) ())
        ""
        (lambda (c) "")
        (list jbug-proxyStarted-response))))

(setq proxyProcess (apply 'start-process "jbugProxy"  (current-buffer) (split-string jbug-proxy)))
(set-process-filter proxyProcess 'jbug-insertion-filter)

#+END_SRC


#+BEGIN_SRC emacs-lisp :tangle jbug.el

(setq jbug-response-hash-table (ht-create))

#+END_SRC

** Debugger Commands

These are the commands a user can enter to the debugger.

Each command is described by a CommandHashEntry. Notice that we are doing low
rent object oriented programming describing each command with a list containing
methods for that command.

The commands are kept in a hash table called commandHashMap. The table is
indexed by the string a user enters to invoke a command. The value for a key is
a CommandHashEntry.  When the user types a command, the command is looked up in
the hash table.

#+BEGIN_SRC emacs-lisp :tangle jbug.el
(defun jbug-makeCommandHashEntry (hashKey badCommandP describeCommand executeCommand proxyDoneP)
  (list hashKey badCommandP describeCommand executeCommand proxyDoneP))

(defun jbug-hashKey                (hashEntry) (nth 0 hashEntry))
(defun jbug-hashBadCommandP        (hashEntry) (nth 1 hashEntry))
(defun jbug-hashDescribeCommand    (hashEntry) (nth 2 hashEntry))
(defun jbug-hashDoCommand          (hashEntry) (nth 3 hashEntry))
(defun jbug-hashProxyDoneP         (hashEntry) (nth 4 hashEntry))

(defun jbug-badCommandP    (e f)   (funcall (jbug-hashBadCommandP e) f))
(defun jbug-checkProxyDone (e f)   (funcall (jbug-hashProxyDoneP e)  f))
(defun jbug-doCommand      (e p f) (funcall (jbug-hashDoCommand e)   p f))

(defconst commandHashMap (ht-create))

#+END_SRC

The commandHashMap is filled with commands below.

*** Input a command

Input to the elisp program comes from the org buffer created when the mode
starts. The user enters a line at the end of the buffer and types a
newline. That line goes to this elisp program because the mode puts a new
routine for newline into its keymap.

If the line is entered at the very bottom of the buffer it is treated as a
command. Otherwise, it is just an ordinary line in a ORG buffer.

Multiple commands can be entered if they are seperated by a semicolon. Each
individual command is a series of tokens seperated by blanks. The first token
identifies the command.

#+BEGIN_SRC emacs-lisp :tangle jbug.el
(defun jbug-newline ()
  (interactive)
  (let ((com (buffer-substring-no-properties
              (line-beginning-position)
              (line-end-position))))
    (if (or
         (/=  (line-end-position) (point-max))
         (not (string-match-p "[a-zA-Z0-9 ]+" com)))
        (org-return)
      (setq jbug-point-in-history 0)
      (beginning-of-line)
      (ignore-errors (kill-line))  ;; kill-line signals an error at the end of buffer
      (jbug-add-commands (split-string com ";" 't)))))
#+END_SRC

There is a command history.

#+BEGIN_SRC emacs-lisp  :tangle jbug.el

(defvar jbug-point-in-history 1 "pointing to the current position in command history")

(defun jbug-get-old-command (count)
  (save-excursion
    (goto-char (point-max))

    (while
        (and
         (> count 0)
         (outline-previous-heading))
      (if
          (and
           (outline-on-heading-p 't)
           (= (- (match-end 0) (match-beginning 0) 1) 3))
          (setq count (1- count))))

    (if
        (and
         (= count 0)
         (outline-on-heading-p 't)
         (= (- (match-end 0) (match-beginning 0) 1) 3))
        (s-trim
         (buffer-substring-no-properties (match-end 0) (progn (end-of-line) (point))))
      ())))

(defun jbug-previous-command-in-history ()
  (interactive)
  (goto-char (point-max))
  (let ((command (jbug-get-old-command (1+ jbug-point-in-history))))
    (when
        command
      (jbug-position-old-command command)
      (setq jbug-point-in-history (1+ jbug-point-in-history)))))

(defun jbug-next-command-in-history ()
  (interactive)
  (goto-char (point-max))
  (when
      (> jbug-point-in-history 1)
    (let ((command (jbug-get-old-command (1- jbug-point-in-history))))
      (when
          command
        (jbug-position-old-command command)
        (setq jbug-point-in-history (1- jbug-point-in-history))))))

(defun jbug-position-old-command (command)
  (goto-char (point-max))
  (beginning-of-line)
  (ignore-errors (kill-line))  ;; kill-line signals an error at the end of buffer
  (insert command))

#+END_SRC

This is the code which runs when the user enters a command. A lot of the work is
done by the jbug-check-commands routine which goes through the list of
commands, looks each one up in the commandHashMap, checks the entered string
with the routine kept in the jbug-hashBadCommandP entry in the command's
CommandHashEntry, puts all the good commands in one list, the bad commands in
another, and returns the two lists. If there are any errors, they are printed
out. If all the commands are good, they are queued for execution by being added
to the commandsToRun list. At the end we run jbug-execute-command which may
send a command to the proxy.

#+BEGIN_SRC emacs-lisp :tangle jbug.el

(defvar commandsToRun  () "list of commands to send to proxy")

(defun jbug-add-commands (com)
  (let* ((r (jbug-check-commands com))
         (good (jbug-check-commands-good r))
         (bad  (jbug-check-commands-bad r)))
    (if (null bad)
        (setq commandsToRun (append commandsToRun good))
      (dolist (v bad)
        (writeStringToBuffer proxyProcess (concat v "\n")))
      (jbug-fix-output-buffer proxyProcess)))
  (jbug-execute-command))

(defun jbug-check-commands (cm)
  (let ((checkErrors ())
        (goodCommands ()))
    (dolist (v cm)
      (let* ((c (split-string v " "  't))
             (hashEntry (ht-get commandHashMap (car c))))
        (if (null hashEntry)
            (setq checkErrors (append checkErrors (list (concat "error - no such command: " v))))
          (if (jbug-badCommandP hashEntry c)
              (setq checkErrors (append checkErrors (list (concat "error - bad command format " v ". Try "  (jbug-hashDescribeCommand hashEntry)))))
            (setq goodCommands
                  (-snoc
                   goodCommands
                   (jbug-describeRunnableCommand
                    (jbug-hashKey hashEntry)
                    v
                    c
                    hashEntry)))))))
        (message "jbug-check-commands cm  %s goodCommands %s checkErrors %s" cm goodCommands checkErrors)
    (list goodCommands checkErrors)))

(defun jbug-check-commands-good (ls)  (nth 0 ls))
(defun jbug-check-commands-bad   (ls)  (nth 1 ls))

#+END_SRC

*** Describing a Command About to be Executed

What exactly gets put on the commandsToRun queue?

Another list pretending to be an object. This list was created in
jbug-check-commands.

The contents of the list are:

0. the comand key in the hash table commandList
1. the command as it was entered
2. the command as it was entered split on blanks into a list
3. the command's entry in the hash table commandHashMap.

An entry in the list is created by the jbug-describeRunnableCommand.

#+BEGIN_SRC emacs-lisp :tangle jbug.el
(defun jbug-describeRunnableCommand (key entered split entry)
  (list key entered split entry))

(defun getKeyFromCommandDescription        (cp)  (nth 0 cp))
(defun getEnteredFromCommandDescription  (cp)  (nth 1 cp))
(defun getSplitFromCommandDescription       (cp)  (nth 2 cp))
(defun getCommandHashEntry             (cp)  (nth 3 cp))

#+END_SRC

*** Run a command

Commands run one at a time, that is, a new command is not started until the
previous command has finished. The command which is currently running is kept in
the variable runningCommand (more exactly, the list create by
describeRunnableCommand for that command is kept in runningCommand).

#+BEGIN_SRC emacs-lisp :tangle jbug.el
(defvar runningCommand   () "the command which is active in the proxy")

(defun proxyBusy ()    runningCommand)
(defun proxyReady ()  (null runningCommand))
#+END_SRC

A command finishes when the proxy returns a response for which it is
waiting. The appropriate responses are contained in the command's
commandHashEntry. Usually that list includes an error response and the internal
interrupt response. When we receive a response from the proxy, we check the
response against the running commands expected responses. If they match, the
running command has finished so we set runningCommand to null and try to start a
new command. All this happens in the routine jbug-checkForCompletedCommand.

#+BEGIN_SRC emacs-lisp :tangle jbug.el
(defun jbug-checkForCompletedCommand (response)
  (when
      (and runningCommand
           (member response (jbug-hashProxyDoneP (getCommandHashEntry runningCommand))))
    (setq runningCommand ())
    (jbug-execute-command)))
#+END_SRC

The command synchronisation mechanism is pretty simple.

Two preconditions must be met before a command is sent to the proxy:

1. No command is in process in the proxy (runningCommand is null),
2. a command is available in the commandsToRun list (commandsToRun is not null).

Whenever one of those preconditions changes we call jbug-execute-command
which checks both. If both hold, we run the command.

All sorts of things are involved in executing a command:

1. the command is put into it's final form, in other words, all defaults get
   added. Note that this is done at the last minute so the defaults might
   have changed from when the command was entered. The work is done
   by a method contained in the command's hashMapEntry which is an
   entry in the list created by jbug-describeRunnableCommand which
   list is the element we took off the front of commandsToRun and placed into
   runningCommand.

2. the command (as an ascii string) goes into the command history,

3. the command is written to output,

4. the command is placed in runningCommand,

5. we run the function contained in the doCommand field of the command's
   commandHashEntry. This usually sends the command to the proxy.

#+BEGIN_SRC emacs-lisp :tangle jbug.el
(defun jbug-execute-command ()
  (when (and commandsToRun (proxyReady))
    (setq runningCommand (car commandsToRun))
    (setq commandsToRun (cdr commandsToRun))
    (message "jbug-execute-command  runningCommand %s commandsToRun %s" runningCommand commandsToRun)
    (writeStringToBuffer proxyProcess (concat "\n" commandHeadline (getEnteredFromCommandDescription runningCommand) "\n"))
    (jbug-doCommand
     (getCommandHashEntry runningCommand)
     proxyProcess
     (getSplitFromCommandDescription runningCommand))))
#+END_SRC

Now we wait for the command to finish or for the user to act.

** Responses from the proxy

The proxy sends message to this elisp program by writing them to its
stdout. EMACS receives the messages on stdin and passes them to this elisp
program by calling the insertion filter defined below.

*** Responses

There is a set of possible responses (or commands if you like) that can be
received from the proxy. A response is a new line terminated ascii string. Each
string is a set of comma seperated values. The first value identifies the
response. Each possible first value is defined as a constant and used as a key
for an entry in the jbug-response-hash-table hash table.

#+BEGIN_SRC emacs-lisp :tangle jbug.el
(setq jbug-response-hash-table (ht-create))
#+END_SRC

For each entry in the table (and so for each response) we create an emacs hook
variable. The value in the jbug-response-hash-table table is a function which
parses the response and calls the functions which were added to the hook. The
idea being that a user can customize the debugger by adding his own functions to
a response's hook.

Here is an example of a response definition. This code runs when a proxy returns
a list of running threads in response to a "threads" command.

#+BEGIN_EXAMPLE

(defconst jbug-threadList-response "threadlist" "")
(defvar jbug-threadList-functions nil)
(setq jbug-threadList-functions ())
(ht-set jbug-response-hash-table
   jbug-threadList-response
   (lambda (response)
       (run-hook-with-args 'jbug-threadList-functions
          (-partition-in-steps 6 6 (-slice response 1)))))

(add-hook 'jbug-threadList-functions
          (lambda (threads)
            (writeOrgTableToBuffer
             proxyProcess
             threadTableTitle
             orgTableSeperator
             threads)))
#+END_EXAMPLE

Responses are defined below.

*** Receive a Response

The proxy sends data to this elisp program through stdout. That data is
manifested to this program when EMACS calls the following routine without
warning. The routine can return a response in pieces so we have to buffer
the string returned. A response is ended by a new line.

When we get a response, we split it on the commas and use the first field to
look up the response's entry in the jbug-response-hash-table hash map. If the
entry exists, it is a function which we execute with a funcall, knowing all
along that the function will execute the hooks for this response. Then we clean
up the output buffer and call jbug-checkForCompletedCommand since the
runningCommand may have finished and it might be time to start another command.

#+BEGIN_SRC emacs-lisp :tangle jbug.el

(setq jbug-receivedFromProxy "")

(defun jbug-insertion-filter (proc string)
  (message "Received: %s :EndReceived" string)
  (setq jbug-receivedFromProxy (concat jbug-receivedFromProxy string))
  (if (s-ends-with? "\n" jbug-receivedFromProxy)
      (let ((com (split-string jbug-receivedFromProxy "\n" 't)))
        (message "jbug-insertion-filter jbug-receivedFromProxy: %s com %s" jbug-receivedFromProxy com)
        (setq jbug-receivedFromProxy "")
        (dolist (c com)
          (if (not (s-blank? c))
              (let* ((response (mapcar 's-trim (split-string c ",")))
                     (responseHook (ht-get jbug-response-hash-table (car response))))
                (if (not responseHook)
                    (message (concat "unknown response " (car response)))
                  ;; well, who knows what came back
                  (condition-case err
                      (funcall responseHook response)
                    (error
                     (progn
                       (setq runningCommand ())
                       (message "Error in a response hook %s"  (error-message-string err)))))
                  (jbug-fix-output-buffer proc)
                  (jbug-checkForCompletedCommand (car response)))))))))

;; make the output buffer right
(defun jbug-fix-output-buffer (proc)
  (when (and (buffer-live-p (process-buffer proc))
             (get-buffer-window (process-buffer proc)))
    (select-window (get-buffer-window (process-buffer proc)))
    (goto-char (point-max))
    (insert "\n")))
#+END_SRC

** Output

The debugger outputs its results by writing them to the process buffer created
when it started. The buffer is an ORG mode buffer.

#+BEGIN_SRC emacs-lisp :tangle jbug.el
  (defconst orgTableSeperator    "|----|\n"                                                               "string to seperate table title from contents")
  (defconst localTableTitle         "|Locals|\n"                                                          "title for local variables table")
  (defconst argumentsTableTitle  "|Arguments|\n"                                                    "title for method arguments table")
  (defconst threadTableTitle       "|ID|Name|State|Frames|Breakpoint|Suspended|\n"     "title for thread table")
  (defconst thisTableTitle          "|This|\n"                                                              "title for this table")

  (defconst sessionHeadline     "* "     "start of debugging session")
  (defconst breakpointHeadline "** "    "reports a breakpoint")
  (defconst commandHeadline  "*** "   "enter a command")
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle jbug.el
  (defun writeStringToBuffer (proc string)
    (when (buffer-live-p (process-buffer proc))
      (with-current-buffer (process-buffer proc)
        (save-excursion
          ;; Insert the text, advancing the process marker.
          (goto-char (point-max))
          (insert string)))))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle jbug.el
  (defun writeOrgTableToBuffer (proc title sep rows)
    (when (buffer-live-p (process-buffer proc))
      (with-current-buffer (process-buffer proc)
        (save-excursion
          ;; Insert the text, advancing the process marker.
          (goto-char (point-max))
          (insert (concat "\n\n" title))
          (let ((tableStart (point)))
            (insert sep)
            (insert (dataLayout rows))
            (goto-char tableStart)
            (ignore-errors (org-ctrl-c-ctrl-c)))))))

  (defun dataLayout (args)
    (if args
        (let ((s "| ")
              (stack ())
              (rc 0)
              (ac 0))
          (push (list rc args) stack)
          (while stack
            (cond
             ((not args)
              (let ((a (pop stack)))
                (setq args (nth 1 a))
                (setq rc     (nth 0 a))))
             ((listp (car args))
              (push (list rc (cdr args)) stack)
              (setq args (car args)))
             ((not (listp (car args)))
              (let ((v (car args)))
                (setq args (cdr args))
                (while (/= rc ac)
                  (cond
                   ((< ac rc)
                    (setq s (concat s " | "))
                    (setq ac (1+ ac)))
                   ((> ac rc)
                    (setq s (concat s "\n| "))
                    (setq ac 0))))
                (setq s (concat s v))
                (setq rc (1+ rc))))))
          s)
      ""))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle jbug.el
(defun reportBreak (preface thread location)
  (setq defaultThread (threadID thread))
  (setq defaultFrame 0)
  (writeStringToBuffer
   proc
   (concat
    breakpointHeadline
    preface
    " in thread "
    (threadID thread)
    " at "
    (locationFile location)
    ":"
    (locationLineNumber location)
    "\n"))
  (setSourceFileWindow
   proc
   (locationFile location)
   (locationLineNumber location)))

(defun threadID               (args) (nth 0 args))
(defun threadName          (args) (nth 1 args))
(defun threadState           (args) (nth 2 args))
(defun threadFrames       (args) (nth 3 args))
(defun threadBreakpoint  (args) (nth 4 args))
(defun threadSuspended (args) (nth 5 args))

(defun locationFile             (args) (nth 0 args))
(defun locationLineNumber (args) (nth 1 args))
(defun locationMethod        (args) (nth 2 args))

#+END_SRC

*** Set windows

We would really like two windows. One with the source file in it, the cursor on
the current line, a bookmark on that line, and that line in the middle of the
window. The other showing the org file with the cursor on the last line. Maybe
we can get this, maybe not.

#+BEGIN_SRC emacs-lisp :tangle jbug.el
(defun setSourceFileWindow (proc file line)
(message (format "setsourcewindow %s | %s | %s\n" sourceDirectory file (concat sourceDirectory file)))
  (let ((bug (find-file-noselect (concat sourceDirectory file))))
    (when (and bug (buffer-live-p (process-buffer proc)))
      (if (= (length (window-list)) 1)
          (split-window))
      (let ((source (winForOtherBuffer bug (process-buffer proc))))
        (if source
            (select-window source)
          (set-buffer bug))
        (goto-char (point-min))
        (forward-line (1- (string-to-number line)))
        (bm-remove-all-all-buffers)
        (bm-toggle)
        (if (eq (window-buffer) bug) (recenter-top-bottom)))
      (let ((procWin (winForOtherBuffer (process-buffer proc) bug)))
        (if procWin
            (select-window procWin)
          (set-buffer (process-buffer proc)))
        (goto-char (point-max))))))

(defun winForOtherBuffer (buffer notbuffer)
  (let ((win (get-buffer-window buffer)))
    (when (not win)
      (let  ((wl (window-list)))
        (while (and wl (eq notbuffer (window-buffer (car wl))))
          (setq wl (cdr wl)))
        (setq win (if wl (car wl) (car (window-list))))
        (set-window-buffer win buffer)))
    win))
#+END_SRC

** Start up

#+BEGIN_SRC emacs-lisp :noweb tangle :tangle jbug.el

(defvar sourceDirectory nil "Root directory of the sources for the target JAVA program")

;;;###autoload
(defun jbug  (src mn host port)
    (interactive "Droot of source tree: \nMmain class: \nMhost: \nMport number: ")
    (message "startProc")
    (find-file (concat mn (format-time-string ".%Y,%m.%d.%H.%M.%S") ".org"))
    (insert "#+STARTUP: showeverything\n")
    (goto-char (point-max))
    (setq sourceDirectory (file-name-as-directory (expand-file-name src)))
    (insert
     (concat
      "\n\n" sessionHeadline
      "Starting debugger session " (current-time-string)
      ".\n\tSource directory: " sourceDirectory
      ".\n\tMain class: " mn
      ".\n\tHost: " host
      ".\n\tPort: "  port ".\n\n"));
    (delete-other-windows)
    (jbug-mode)

    ;; start the proxy

    <<start-proxy>>

    (goto-char (point-max))
    (set-marker (process-mark proxyProcess) (point))
    (insert (format "attach %s %s;prepare %s;wait classprepared;break %s main;catch on;continue" host port mn mn))
    (jbug-newline))
#+END_SRC

** Commands and responses

#+BEGIN_SRC emacs-lisp :tangle jbug.el#+BEGIN_SRC emacs-lisp :tangle jbug.el
(defconst jbug-accessWatchpoint-response "accesswatchpoint" "")
(defconst jbug-accessWatchpointSet-response "accesswatchpointset" "")
(defconst jbug-arguments-response "arguments" "")
(defconst jbug-breakpointCleared-response "breakpointcleared" "")
(defconst jbug-breakpointCreated-response "breakpointcreated" "")
(defconst jbug-breakpointEntered-response "breakpointentered" "")
(defconst jbug-breakpointList-response "breakpointlist" "")
(defconst jbug-catchEnabled-response "catchenabled" "")
(defconst jbug-classPrepared-response "classprepared" "")
(defconst jbug-classUnloaded-response "classunloaded" "")
(defconst jbug-classes-response "classes" "")
(defconst jbug-error-response "error" "")
(defconst jbug-exception-response "exception" "")
(defconst jbug-fields-response "fields" "")
(defconst jbug-internalException-response "internalexception" "")
(defconst jbug-locals-response "locals" "")
(defconst jbug-log-response "log" "")
(defconst jbug-modificationWatchpoint-response "modificationwatchpoint" "")
(defconst jbug-modificationWatchpointSet-response "modificationwatchpointset" "")
(defconst jbug-preparingClass-response "preparingclass" "")
(defconst jbug-proxyExited-response "proxyexited" "")
(defconst jbug-proxyStarted-response "proxystarted" "")
(defconst jbug-stack-response "stack" "")
(defconst jbug-step-response "step" "")
(defconst jbug-stepCreated-response "stepcreated" "")
(defconst jbug-this-response "this" "")
(defconst jbug-threadDied-response "threaddied" "")
(defconst jbug-threadList-response "threadlist" "")
(defconst jbug-threadStarted-response "threadstarted" "")
(defconst jbug-vmCreated-response "vmcreated" "")
(defconst jbug-vmDied-response "vmdied" "")
(defconst jbug-vmDisconnected-response "vmdisconnected" "")
(defconst jbug-vmResumed-response "vmresumed" "")
(defconst jbug-vmStarted-response "vmstarted" "")
#+END_SRC

**** access

Set an access watchpoint.

Request for notification when the contents of a field are accessed in the target
VM. This event will be triggered when the specified field is accessed by Java
programming language code or by a Java Native Interface (JNI) get function.

#+BEGIN_SRC emacs-lisp :tangle jbug.el

(ht-set
 commandHashMap
 "access"
 (jbug-makeCommandHashEntry
  "access"
  (lambda (c) (/= (length c) 3))
  "access class-name field-name"
  (lambda (proxy c)
    (process-send-string
     proxy
     (format
      "access,%s,%s\n"
      (nth 1 c)
      (nth 2 c))))
  (list jbug-accessWatchpointSet-response jbug-error-response jbug-internalException-response jbug-exception-response)))

(defvar jbug-accessWatchpointSet-functions nil)
(setq jbug-accessWatchpointSet-functions ())

(ht-set
 jbug-response-hash-table
 jbug-accessWatchpointSet-response
 (lambda (response)
   (run-hook-with-args
    'jbug-accessWatchpointSet-functions
    (nth 1 response)
    (nth 2 response))))

(add-hook
 'jbug-accessWatchpointSet-functions
 (lambda (class field)
   (writeStringToBuffer proc (concat "Access watchpoint set for field " field " in class " class ".\n"))))

(defvar jbug-accessWatchpoint-functions nil)
(setq jbug-accessWatchpoint-functions ())

(ht-set jbug-response-hash-table
        jbug-accessWatchpoint-response
        (lambda (response)
          (run-hook-with-args 'jbug-accessWatchpoint-functions
                              (nth 1 response)
                              (nth 2 response)
                              (nth 0 (read-from-string (nth 3 response))))))

(add-hook 'jbug-accessWatchpoint-functions
          (lambda (className fieldName value)
            (writeStringToBuffer proxyProcess  "Access watchpoint\n")
            (writeOrgTableToBuffer
             proxyProcess
             "|Class:Field|Value|\n"
             orgTableSeperator
             (list (concat className ":" fieldName) value))))



#+END_SRC

**** arguments

Print the arguments to a method.

By default prints all local variables but can specify the variables to print
with a variable descriptor string.

#+BEGIN_SRC emacs-lisp :tangle jbug.el

(ht-set
 commandHashMap
 "arguments"
 (jbug-makeCommandHashEntry
  "arguments"
  (lambda (c) (and (/= (length c) 1) (/= (length c) 2)))
  "arguments [variable names]"
  (lambda (proxy c)
    (process-send-string
     proxy
     (format
      "arguments,%s,%s,%s\n"
      defaultThread
      (number-to-string defaultFrame)
      (setDotNotation (if (= (length c) 2) (nth 1 c) "")))))
  (list
   jbug-arguments-response
   jbug-error-response
   jbug-internalException-response
   jbug-exception-response)))

(defvar jbug-arguments-functions nil)
(setq   jbug-arguments-functions ())

(ht-set
 jbug-response-hash-table
 jbug-arguments-response
 (lambda (response)
   (run-hook-with-args
    'jbug-arguments-functions
    (nth 1 response)
    (nth 2 response)
    (nth 0 (read-from-string (nth 3 response))))))

(add-hook
 'jbug-arguments-functions
 (lambda (thread frame th)
   (writeStringToBuffer
    proxyProcess
    (format "Arguments for thread %s frame number %s.\n" thread frame))
   (writeOrgTableToBuffer
    proxyProcess
    "| Name | Value |\n"
    orgTableSeperator
    th)))

#+END_SRC

**** attach

Attach the debugger to the target VM.

#+BEGIN_SRC emacs-lisp :tangle jbug.el

(ht-set
 commandHashMap
 "attach"
   (jbug-makeCommandHashEntry "attach"
                               (lambda (c) (or (/= (length c) 3)  (not (string-match "[0-9]+" (nth 2 c)))))
                               "attach host  [port number ]"
                               (lambda (proxy c)
                                 (process-send-string
                                  proxy
                                  (format "attach,%s,%s\n" (nth 1 c) (nth 2 c))))
                               (list jbug-vmStarted-response  jbug-error-response jbug-internalException-response jbug-exception-response)))

(defvar jbug-vmCreated-functions nil)
(setq jbug-vmCreated-functions ())
(ht-set jbug-response-hash-table
   jbug-vmCreated-response
   (lambda (response) (run-hooks 'jbug-vmCreated-functions )))

(add-hook 'jbug-vmCreated-functions (lambda ()
        (writeStringToBuffer proxyProcess "virtual machine created\n")))

(defconst jbug-vmStarted-response "vmstarted" "")
(defvar jbug-vmStarted-functions nil)
(setq jbug-vmStarted-functions ())
(ht-set jbug-response-hash-table
   jbug-vmStarted-response
   (lambda (response) (run-hooks 'jbug-vmStarted-functions )))

(add-hook 'jbug-vmStarted-functions (lambda ()
              (writeStringToBuffer proxyProcess "virtual machine started\n")))

#+END_SRC

**** break

Set a breakpoint in the target VM.

#+BEGIN_SRC emacs-lisp :tangle jbug.el

(ht-set
 commandHashMap
 "break"
 (jbug-makeCommandHashEntry
  "break"
  (lambda (c) (/= (length c) 3))
  "break class-name <line-number|method name>"
  (lambda (proxy c)
    (process-send-string
     proxy
     (format "break,%s,%s\n" (nth 1 c) (nth 2 c))))
  (list jbug-breakpointCreated-response jbug-error-response jbug-internalException-response jbug-exception-response)))

(defvar jbug-breakpointCreated-functions nil)
(setq jbug-breakpointCreated-functions ())

(ht-set
 jbug-response-hash-table
 jbug-breakpointCreated-response
 (lambda (response)
   (run-hook-with-args
    'jbug-breakpointCreated-functions
    (nth 1 response)
    (-slice response 2 5))))

(add-hook
 'jbug-breakpointCreated-functions
 (lambda (breakId loc)
   (writeStringToBuffer proc (concat "Breakpoint  " breakId " created at " (jbug-LocationString loc)  ".\n"))))

(defvar jbug-breakpointEntered-functions nil)
(setq jbug-breakpointEntered-functions ())

(ht-set
 jbug-response-hash-table
 jbug-breakpointEntered-response
 (lambda (response)
   (run-hook-with-args
    'jbug-breakpointEntered-functions
    (nth 1 response)
    (-slice response 2 8)
    (-slice response 8))))

(add-hook
 'jbug-breakpointEntered-functions
 (lambda (breakId tr loc)
   (reportBreak (concat "Breakpoint " breakId " entered") tr loc)))

#+END_SRC

**** breaks

List breakpoints enabled in the target VM.

#+BEGIN_SRC emacs-lisp :tangle jbug.el

(ht-set
 commandHashMap
 "breaks"
   (jbug-makeCommandHashEntry "breaks"
                                   (lambda (c) (/= (length c) 1))
                                   "breaks"
                                   (lambda (proxy c)
                                     (process-send-string
                                      proxy
                                      "breaks\n"))
                               (list
                                jbug-breakpointList-response
                                jbug-error-response
                                jbug-internalException-response
                                jbug-exception-response)))

(defvar jbug-breakpointList-functions nil)
(setq   jbug-breakpointList-functions nil)

(ht-set
 jbug-response-hash-table
 jbug-breakpointList-response
 (lambda (response)
   (run-hook-with-args
    'jbug-breakpointList-functions
    (mapcar
     (lambda (x)
       (list
        (car x)
        (-slice x 1)))
     (-partition-in-steps 4 4 (-slice response  1))))))

(defun jbug-display-breakpoints (breakpoints)
  (writeStringToBuffer
   proxyProcess
   "Breakpoints")
  (writeOrgTableToBuffer
   proxyProcess
   "|id|location|\n"
   orgTableSeperator
   (mapcar
    (lambda (x)
      (list
       (nth 0 x)
       (concat (nth 0 (nth 1 x)) ":" (nth 1 (nth 1 x)))))
    breakpoints)))

(add-hook
 'jbug-breakpointList-functions
 'jbug-display-breakpoints)
#+END_SRC
**** catch

Request notification when an exception occurs in the target VM.

#+BEGIN_SRC emacs-lisp :tangle jbug.el

(ht-set
 commandHashMap
 "catch"
   (jbug-makeCommandHashEntry "catch"
                               (lambda (c) (or (/= (length c) 2)  (and (not (string-match "on" (nth 1 c))) (not (string-match "off" (nth 1 c))))))
                               "catch on|off"
                               (lambda (proxy c)
                                 (process-send-string
                                  proxy
                                  (format
                                   "catch,%s\n"
                                   (nth 1 c))))
                               (list jbug-catchEnabled-response jbug-error-response jbug-internalException-response jbug-exception-response)))

(defvar jbug-catchEnabled-functions nil)
(setq jbug-catchEnabled-functions ())

(ht-set jbug-response-hash-table
   jbug-catchEnabled-response
   (lambda (response) (run-hook-with-args 'jbug-catchEnabled-functions (nth 1 response))))

 (add-hook 'jbug-catchEnabled-functions
          (lambda (enabled)
            (writeStringToBuffer
             proc
             (format "Exceptions %s\n" (if (string= enabled "true") "enabled" "disabled")))))

(defvar jbug-exception-functions nil)
(setq jbug-exception-functions ())

(ht-set jbug-response-hash-table
   jbug-exception-response
   (lambda (response)
     (run-hook-with-args
      'jbug-exception-functions
      (nth 1 response)
      (-slice response 2 5)
      (nth 5 response)
      (nth 0 (read-from-string (nth 6 response))))))

(add-hook 'jbug-exception-functions
          (lambda ( name loc message stack)
            (writeStringToBuffer
             proc
             (concat
              name " occured in target at " (jbug-LocationString loc) "\nMessage: " message "\nStack Trace:\n"))
            (let ((c (mapcar (lambda (x) (-slice (assoc "fields" x) 1))  (-slice (assoc "contents"  stack) 1))))
              (-each
                  (-partition 3
                              (-interleave
                               (mapcar (lambda (x) (nth 1 (assoc "fileName" x))) c)
                               (mapcar (lambda (x) (nth 1 (assoc "lineNumber" x))) c)
                               (mapcar (lambda (x) (nth 1 (assoc "methodName" x))) c)))
                (lambda (x) (writeStringToBuffer proc (format " %s\n" (jbug-LocationString x))))))))

#+END_SRC

**** classes

Print all classes loaded in the target VM.

#+BEGIN_SRC emacs-lisp :tangle jbug.el

(ht-set
 commandHashMap
 "classes"
   (jbug-makeCommandHashEntry "classes"
                               (lambda (c) (/= (length c) 1))
                               "classes"
                               (lambda (proxy c)
                                 (process-send-string
                                  proxy
                                  "classes\n"))
                               (list jbug-classes-response jbug-error-response jbug-internalException-response jbug-exception-response)))

(defvar jbug-classes-functions nil)
(setq jbug-classes-functions ())
(ht-set jbug-response-hash-table
   jbug-classes-response
   (lambda (response) (run-hook-with-args 'jbug-classes-functions  (-slice response 1))))

(add-hook 'jbug-classes-functions
          (lambda (classes)
            (writeStringToBuffer
             proc
             "classes\n")
            (dolist (r classes)
              (writeStringToBuffer
               proc
               (format "%s\n" r)))))

#+END_SRC
**** clear

Clear all breakpoints or the specified breakpoint.

#+BEGIN_SRC emacs-lisp :tangle jbug.el

(ht-set
 commandHashMap
 "clear"
   (jbug-makeCommandHashEntry "clear"
                                   (lambda (c)
                                     (or (/= (length c) 2)
                                         (and
                                          (not (string-match "[0-9]+" (nth 1 c)))
                                          (not (string= "all" (nth 1 c))))))
                               "clear [breakpoint-id/all]"
                               (lambda (proxy c)
                                 (process-send-string
                                  proxy
                                  (format
                                   "clear,%s\n"
                                   (nth 1 c))))
                               (list jbug-breakpointList-response jbug-error-response jbug-internalException-response jbug-exception-response)))

(defvar jbug-breakpointCleared-functions nil)
(setq   jbug-breakpointCleared-functions nil)

(ht-set
 jbug-response-hash-table
 jbug-breakpointCleared-response
 (lambda (response)
   (run-hook-with-args
    'jbug-breakpointList-functions
    (mapcar
     (lambda (x)
       (list
        (car x)
        (-slice x 1)))
     (-partition-in-steps 4 4 (-slice response  1))))))

(add-hook
 'jbug-breakpointCleared-functions
 'jbug-display-breakpoints)

#+END_SRC
**** down

Set the default frame to the frame directly below the current default frame.

#+BEGIN_SRC emacs-lisp :tangle jbug.el

(ht-set
 commandHashMap
 "down"
   (jbug-makeCommandHashEntry "down"
                               (lambda (c) (/= (length c) 1))
                               "down"
                               (lambda (proxy c)
                                 (setq defaultFrame (1+ defaultFrame))
                                 (process-send-string
                                  proxy
                                  (format
                                   "stack,%s\n"
                                   defaultThread)))
                               (list jbug-stack-response jbug-error-response jbug-internalException-response jbug-exception-response)))
#+END_SRC

**** fields

Prints all the fields of a given class.

#+BEGIN_SRC emacs-lisp :tangle jbug.el

(ht-set
 commandHashMap
 "fields"
   (jbug-makeCommandHashEntry "fields"
                               (lambda (c) (/= (length c) 2))
                               "fields"
                               (lambda (proxy c)
                                 (process-send-string
                                  proxy
                                  (format "fields,%s\n" (nth 1 c))))
                               (list  jbug-fields-response jbug-error-response jbug-internalException-response jbug-exception-response)))

(defvar jbug-fields-functions nil)
(setq jbug-fields-functions ())
(ht-set jbug-response-hash-table
   jbug-fields-response
   (lambda (response) (run-hook-with-args 'jbug-fields-functions  (nth 1 response) (-partition-in-steps 8 8 (-slice response 2)))))

(add-hook 'jbug-fields-functions
          (lambda (className fields)
            (writeStringToBuffer proxyProcess (concat "Fields for class: " className "\n"))
            (writeOrgTableToBuffer
             proxyProcess
             "|Field |Type|Declaring Type|Enum|Transient|Volatile|Final|Static|\n"
             orgTableSeperator
             fields)))

#+END_SRC

**** frame

#+BEGIN_SRC emacs-lisp :tangle jbug.el

(ht-set
 commandHashMap
 "frame"
   (jbug-makeCommandHashEntry "frame"
                               (lambda (c) (/= (length c) 1))
                               "frame (default thread) (defaultFrame)"
                               (lambda (proxy c)
                                 (process-send-string
                                  proxy
                                  (format
                                   "frame,%s,%s\n"
                                   defaultThread
                                   defaultFrame)))
                               (lambda (r) (string= (car r) "arguments"))))
#+END_SRC
**** help

Prints a short description of every debugger command.

#+BEGIN_SRC emacs-lisp :tangle jbug.el

(ht-set
 commandHashMap
 "help"
   (jbug-makeCommandHashEntry "help"
                               (lambda (c) ())
                               "help"
                               (lambda (proxy c)
                                 (dolist (v
                                          (sort (ht-map (lambda (key value) (jbug-hashDescribeCommand value)) commandHashMap) 'string<))
                                  (writeStringToBuffer proxy (concat v "\n")))
                                 (setq runningCommand ())
                                 (jbug-fix-output-buffer proxyProcess))
                               (lambda (r) (string= (car r) "help"))))
#+END_SRC

**** wait

For use in command lists. Pauses execution of commands in the list until a
breakpoint is entered or a class is prepared.


Now this is a fairly amusing command.

It's entered like this:

     wait breakpointentered

or

     wait classprepared.

In the first case it sends a run command to the proxy and waits for a
breakpointentered response. In the second, it sends a run command to the proxy
and waits for a classprepared response.

When runningCommand is set to this command and the command is executed (i.e. the
second lamda expression in the commandHashEntry runs) the code looks in
runningCommand, picks out the commandHashEnry, picks the response list field out
of the commandHashEntry, and sets it to a list containing - among other things,
the second argument of the wait command. All this happens in the setf instruction
below.

#+BEGIN_SRC emacs-lisp :tangle jbug.el

(ht-set
 commandHashMap
 "wait"
   (jbug-makeCommandHashEntry "wait"
                               (lambda (c) (/= (length c) 2))
                               "wait"
                               (lambda (proxy c)
                                 (setf
                                  (nth 4 (nth 3 runningCommand))
                                  (list (nth 1 c) jbug-error-response jbug-internalException-response jbug-exception-response))
                                 (process-send-string
                                  proxy
                                  "run\n"))
                               ()))

(defvar jbug-classPrepared-functions nil)
(setq jbug-classPrepared-functions ())
(ht-set jbug-response-hash-table
   jbug-classPrepared-response
   (lambda (response) (run-hook-with-args 'jbug-classPrepared-functions response)))

(add-hook 'jbug-classPrepared-functions (lambda ( resp)
            (writeStringToBuffer proc (concat  (s-join " " resp) ".\n"))))

#+END_SRC

**** locals

Print local variables with their values.

By default prints all local variables but can specify the variables to print
with a variable descriptor string.

#+BEGIN_SRC emacs-lisp :tangle jbug.el

(ht-set
 commandHashMap
 "locals"
 (jbug-makeCommandHashEntry
  "locals"
  (lambda (c) (and (/= (length c) 1) (/= (length c) 2)))
  "locals [variable names]"
  (lambda (proxy c)
    (process-send-string
     proxy
     (format
      "locals,%s,%s,%s\n"
      defaultThread
      (number-to-string defaultFrame)
      (setDotNotation (if (= (length c) 2) (nth 1 c) "")))))
  (list jbug-locals-response jbug-error-response jbug-internalException-response jbug-exception-response)))

(defvar jbug-locals-functions nil)
(setq jbug-locals-functions ())
(ht-set jbug-response-hash-table
        jbug-locals-response
        (lambda (response)
          (run-hook-with-args
           'jbug-locals-functions
           (nth 1 response)
      (nth 2 response)
      (nth 0 (read-from-string (nth 3 response))))))

(add-hook
 'jbug-locals-functions
 (lambda (thread frame th)
   (writeStringToBuffer
    proxyProcess
    (format "Locals for thread %s frame number %s.\n" thread frame))
   (writeOrgTableToBuffer
    proxyProcess
    "| Name | Value |\n"
    orgTableSeperator
    th)))

#+END_SRC

**** back, into, next

Execute a single step in the target VM.

back - step out of the current frame
into - step to the next location on a different line or into a new frame,
next - step to the next location on a different line and over a new frame.

#+BEGIN_SRC emacs-lisp :tangle jbug.el

(ht-set
 commandHashMap
 "back"
   (jbug-makeCommandHashEntry "back"
                               (lambda (c) (or (> (length c) 2)  (and (= (length c) 2) (not (string-match "[0-9]+" (nth 1 c))))))
                               "back [thread-id]"
                               (lambda (proxy c)
                                 (process-send-string
                                  proxy
                                  (format
                                   "back,%s\n"
                                   (if (= (length c) 1) defaultThread (nth 1 c)))))
                               (list jbug-stepCreated-response jbug-error-response jbug-internalException-response jbug-exception-response)))

(ht-set
 commandHashMap
 "into"
   (jbug-makeCommandHashEntry "into"
                               (lambda (c) (or (> (length c) 2)  (and (= (length c) 2) (not (string-match "[0-9]+" (nth 1 c))))))
                               "into [thread-id]"
                               (lambda (proxy c)
                                 (process-send-string
                                  proxy
                                  (format
                                   "into,%s\n"
                                   (if (= (length c) 1) defaultThread (nth 1 c)))))
                               (list jbug-stepCreated-response jbug-error-response jbug-internalException-response jbug-exception-response)))

(ht-set
 commandHashMap
 "next"
   (jbug-makeCommandHashEntry "next"
                               (lambda (c) (or (> (length c) 2)  (and (= (length c) 2) (not (string-match "[0-9]+" (nth 1 c))))))
                               "next [thread-id]"
                               (lambda (proxy c)
                                 (process-send-string
                                  proxy
                                  (format
                                   "next,%s\n"
                                   (if (= (length c) 1) defaultThread (nth 1 c)))))
                               (list jbug-stepCreated-response jbug-error-response jbug-internalException-response jbug-exception-response)))

(defvar jbug-stepCreated-functions nil)
(setq jbug-stepCreated-functions ())
(ht-set jbug-response-hash-table
   jbug-stepCreated-response
   (lambda (response) (run-hooks 'jbug-stepCreated-functions )))

;;(add-hook 'jbug-stepCreated-functions (lambda ()

(defvar jbug-step-functions nil)
(setq jbug-step-functions ())
(ht-set jbug-response-hash-table
   jbug-step-response
   (lambda (response) (run-hook-with-args 'jbug-step-functions  (-slice response 1 7) (-slice response 7))))

(add-hook 'jbug-step-functions
        (lambda (tr loc)
            (reportBreak "step" tr loc)))

#+END_SRC

**** modify

Set a modification watchpoint.

Request notification when a field is set. This event will be triggered when a
value is assigned to the specified field with a Javatatement (assignment,
increment, etc) or by a Java Native Interface (JNI) set function Setting a field
to a value which is the same as the previous value still triggers this event.

#+BEGIN_SRC emacs-lisp :tangle jbug.el

(ht-set
 commandHashMap
 "modify"
   (jbug-makeCommandHashEntry "modify"
                               (lambda (c) (/= (length c) 3))
                               "modify class-name field-name"
                                (lambda (proxy c)
                                 (process-send-string
                                  proxy
                                  (format
                                  "modify,%s,%s\n"
                                   (nth 1 c)
                                   (nth 2 c))))
                               (list jbug-modificationWatchpointSet-response jbug-error-response jbug-internalException-response jbug-exception-response)))

(defvar jbug-modificationWatchpointSet-functions nil)
(setq jbug-modificationWatchpointSet-functions ())
(ht-set jbug-response-hash-table
   jbug-modificationWatchpointSet-response
   (lambda (response) (run-hooks 'jbug-modificationWatchpointSet-functions )))

(add-hook 'jbug-modificationWatchpointSet-functions (lambda ()
            (writeStringToBuffer proc (concat "Modification watchpoint set.\n"))))

(defvar jbug-modificationWatchpoint-functions nil)
(setq jbug-modificationWatchpoint-functions ())
(ht-set jbug-response-hash-table
   jbug-modificationWatchpoint-response
   (lambda (response)
     (run-hook-with-args 'jbug-modificationWatchpoint-functions
                         (nth 1 response)
                         (nth 2 response)
                         (nth 0 (read-from-string (nth 3 response)))
                         (nth 0 (read-from-string (nth 4 response))))))

(add-hook
 'jbug-modificationWatchpoint-functions
 (lambda (className fieldName past future)
   (writeStringToBuffer proxyProcess "Modification watchpoint\n")
   (writeOrgTableToBuffer
    proxyProcess
    "| Object:Field | When | Value |\n"
    orgTableSeperator
    (list (concat className ":" fieldName) (list "Before" past) (list "After" future)))))

#+END_SRC

**** prepare

Request notification when a class is prepared in the target VM.

#+BEGIN_SRC emacs-lisp :tangle jbug.el

(ht-set
 commandHashMap
 "prepare"
   (jbug-makeCommandHashEntry "prepare"
                               (lambda (c) (/= (length c) 2))
                               "prepare [class name]"
                               (lambda (proxy c)
                                 (process-send-string
                                  proxy
                                  (format "prepare,%s\n" (nth 1 c))))
                               (list jbug-preparingClass-response jbug-error-response jbug-internalException-response jbug-exception-response)))

(defvar jbug-preparingClass-functions nil)
(setq jbug-preparingClass-functions ())
(ht-set jbug-response-hash-table
   jbug-preparingClass-response
   (lambda (response) (run-hook-with-args 'jbug-preparingClass-functions  (nth 1 response))))

(add-hook 'jbug-preparingClass-functions (lambda (name)
            (writeStringToBuffer proc (concat "Preparing class " name ".\n"))))

#+END_SRC

**** quit

End the debugging session.

#+BEGIN_SRC emacs-lisp :tangle jbug.el

(ht-set
 commandHashMap
 "quit"
   (jbug-makeCommandHashEntry "quit"
                               (lambda (c) (/= (length c) 1))
                               "quit"
                               (lambda (proxy c)
                                 (process-send-string
                                  proxy
                                  "quit\n"))
                               (lambda (r) (string= (car r) "proxy"))))

(defvar jbug-proxyExited-functions nil)
(setq jbug-proxyExited-functions ())
(ht-set jbug-response-hash-table
   jbug-proxyExited-response
   (lambda (response) (run-hooks 'jbug-proxyExited-functions )))

(add-hook 'jbug-proxyExited-functions (lambda ()
            (writeStringToBuffer proxyProcess "Debugger proxy exited\n")))

(defvar jbug-vmDisconnected-functions nil)
(setq jbug-vmDisconnected-functions ())
(ht-set jbug-response-hash-table
   jbug-vmDisconnected-response
   (lambda (response) (run-hooks 'jbug-vmDisconnected-functions )))

(add-hook 'jbug-vmDisconnected-functions (lambda ()
        (writeStringToBuffer proxyProcess "virtual machine disconnected\n")))

(defvar jbug-vmDied-functions nil)
(setq jbug-vmDied-functions ())
(ht-set jbug-response-hash-table
   jbug-vmDied-response
   (lambda (response) (run-hooks 'jbug-vmDied-functions )))

(add-hook 'jbug-vmDied-functions (lambda ()
        (writeStringToBuffer proxyProcess "virtual machine terminated\n")))

#+END_SRC

**** run

Start or resume program execution.

#+BEGIN_SRC emacs-lisp :tangle jbug.el

(ht-set
 commandHashMap
 "run"
   (jbug-makeCommandHashEntry "run"
                               (lambda (c) (/= (length c) 1))
                               "run"
                               (lambda (proxy c)
                                 (process-send-string
                                  proxy
                                  "run\n"))
                               (list jbug-vmResumed-response jbug-error-response jbug-internalException-response jbug-exception-response)))

(ht-set
 commandHashMap
 "continue"
   (jbug-makeCommandHashEntry "continue"
                               (lambda (c) (/= (length c) 1))
                               "continue"
                               (lambda (proxy c)
                                 (process-send-string
                                  proxy
                                  "run\n"))
                               (list jbug-vmResumed-response jbug-error-response jbug-internalException-response jbug-exception-response)))

(defvar jbug-vmResumed-functions nil)
(setq jbug-vmResumed-functions ())
(ht-set jbug-response-hash-table
   jbug-vmResumed-response
   (lambda (response) (run-hooks 'jbug-vmResumed-functions )))

(add-hook 'jbug-vmResumed-functions (lambda ()
        (writeStringToBuffer proxyProcess "virtual machine resuming operation.\n")))

#+END_SRC

**** set

Set the defaultThread which will be used by future commands. Use the 'threads'
command to get a list of threads and their ids.

#+BEGIN_SRC emacs-lisp :tangle jbug.el

(ht-set
 commandHashMap
 "set"
   (jbug-makeCommandHashEntry "set"
                               (lambda (c) (or (/= (length c) 2)  (not (string-match "[0-9]+" (nth 1 c)))))
                               "set [thread-id]"
                               (lambda (proxy c)
                                 (setq defaultThread (nth 1 c))
                                 (process-send-string
                                  proxy
                                  "threads\n"))
                               (list jbug-threadList-response jbug-error-response jbug-internalException-response jbug-exception-response)))

#+END_SRC

**** stack

Print the stack of method calls which have brought us to this point.

#+BEGIN_SRC emacs-lisp :tangle jbug.el

(ht-set
 commandHashMap
 "stack"
   (jbug-makeCommandHashEntry "stack"
                               (lambda (c) (/= (length c) 1))
                               "stack"
                               (lambda (proxy c)
                                 (process-send-string
                                  proxy
                                  (format
                                   "stack,%s\n"
                                   defaultThread)))
                               (list jbug-stack-response jbug-error-response jbug-internalException-response jbug-exception-response)))

(defvar jbug-stack-functions nil)
(setq jbug-stack-functions ())
(ht-set jbug-response-hash-table
   jbug-stack-response
   (lambda (response) (run-hook-with-args 'jbug-stack-functions (nth 1 response) (-partition-in-steps 3 3 (-slice response 2)))))

(add-hook 'jbug-stack-functions
          (lambda (id locations)
            (writeStringToBuffer proxyProcess (concat "Stack for thread " id " \n"))
            (writeOrgTableToBuffer
             proxyProcess
             "||Frame|File|Line|Method|\n"
             orgTableSeperator
             (let ((ff ())
                   (locs locations))
               (dotimes (i (length locs))
                 (setq ff
                       (cons
                        (cons
                         (if (= i defaultFrame) "*" "")
                         (cons
                          (number-to-string i)
                          (nth i locs)))
                        ff)))
               (reverse ff)))
            (when (< defaultFrame (length locations))
              (let ((loc (nth defaultFrame locations)))
                (setSourceFileWindow
                 proxyProcess
                 (locationFile loc)
                 (locationLineNumber loc))))))

#+END_SRC

**** this

Prints the object pointed to by the 'this' JAVA keyword in the default thread
and default frame.

#+BEGIN_SRC emacs-lisp :tangle jbug.el

(ht-set
 commandHashMap
 "this"
 (jbug-makeCommandHashEntry
  "this"
  (lambda (c) (and (/= (length c) 1) (/= (length c) 2)))
  "this [default-thread-id] [default-frame number]"
  (lambda (proxy c)
    (process-send-string
     proxy
     (format
      "this,%s,%s,%s\n"
      defaultThread
      (number-to-string defaultFrame)
      (setDotNotation (if (= (length c) 2) (nth 1 c) "")))))
  (list
   jbug-this-response
   jbug-error-response
   jbug-internalException-response
   jbug-exception-response)))

(defvar jbug-this-functions nil)
(setq jbug-this-functions ())

(ht-set
 jbug-response-hash-table
 jbug-this-response
 (lambda (response)
   (run-hook-with-args
    'jbug-this-functions
    (nth 1 response)
    (nth 2 response)
    (nth 0 (read-from-string (nth 3 response))))))

(add-hook
 'jbug-this-functions
 (lambda (thread frame th)
   (writeStringToBuffer
    proxyProcess
    (format "This for thread %s frame number %s.\n" thread frame))
   (writeOrgTableToBuffer
    proxyProcess
    thisTableTitle
    orgTableSeperator
    th)))

#+END_SRC

**** threads

Prints the running threads and their status.

#+BEGIN_SRC emacs-lisp :tangle jbug.el

(ht-set
 commandHashMap
 "threads"
   (jbug-makeCommandHashEntry "threads"
                                   (lambda (c) (/= (length c) 1))
                                   "threads"
                                   (lambda (proxy c)
                                     (process-send-string
                                      proxy
                                      "threads\n"))
                               (list jbug-threadList-response jbug-error-response jbug-internalException-response jbug-exception-response)))

(defvar jbug-threadList-functions nil)
(setq jbug-threadList-functions ())
(ht-set jbug-response-hash-table
   jbug-threadList-response
   (lambda (response) (run-hook-with-args 'jbug-threadList-functions (-partition-in-steps 6 6 (-slice response 1)))))

(add-hook 'jbug-threadList-functions
          (lambda (threads)
            (writeOrgTableToBuffer
             proxyProcess
             threadTableTitle
             orgTableSeperator
             threads)))

#+END_SRC

**** up

Decrement defaultFrame moving it closer to the current frame.

#+BEGIN_SRC emacs-lisp :tangle jbug.el

(ht-set
 commandHashMap
 "up"
   (jbug-makeCommandHashEntry "up"
                               (lambda (c) (or (/= (length c) 1) (<= defaultFrame 0)))
                               "up"
                               (lambda (proxy c)
                                 (setq defaultFrame (1- defaultFrame))
                                 (process-send-string
                                  proxy
                                  (format
                                   "stack,%s\n"
                                   defaultThread)))
                               (list jbug-stack-response jbug-error-response jbug-internalException-response jbug-exception-response)))
#+END_SRC

*** Miscellaneous responses from the debugger proxy

#+BEGIN_SRC emacs-lisp :tangle jbug.el

(defvar jbug-classUnloaded-functions nil)
(setq jbug-classUnloaded-functions ())
(ht-set jbug-response-hash-table
   jbug-classUnloaded-response
   (lambda (response) (run-hook-with-args 'jbug-classUnloaded-functions (nth 1 response))))

;;(add-functions 'jbug-classUnloaded-functions (lambda ( className)

(defvar jbug-error-functions nil)
(setq jbug-error-functions ())
(ht-set jbug-response-hash-table
   jbug-error-response
   (lambda (response) (run-hook-with-args 'jbug-error-functions (nth 1 response))))

(add-hook 'jbug-error-functions (lambda ( error)
            (writeStringToBuffer proc (concat "Error: "  error "\n"))))

;; internalException
(defvar jbug-internalException-functions nil)
(setq jbug-internalException-functions ())
(ht-set jbug-response-hash-table
   jbug-internalException-response
        (lambda (response) (run-hook-with-args 'jbug-internalException-functions (nth  1 response) (nth 2 response))))

(add-hook 'jbug-internalException-functions
          (lambda (msg stack)
            (writeStringToBuffer proc (concat "Internal exception in proxy: " msg "\n" stack "\n"))))

;; log
(defvar jbug-log-functions nil)
(setq jbug-log-functions ())
(ht-set jbug-response-hash-table
   jbug-log-response
   (lambda (response) (run-hook-with-args 'jbug-log-functions (nth 1 response))))

;; log
(add-hook 'jbug-log-functions (lambda ( resp)
            (writeStringToBuffer proc (concat  (s-join " " resp) ".\n"))))

;; proxyStarted
(defvar jbug-proxyStarted-functions nil)
(setq jbug-proxyStarted-functions ())
(ht-set jbug-response-hash-table
   jbug-proxyStarted-response
   (lambda (response) (run-hooks 'jbug-proxyStarted-functions )))

(add-hook 'jbug-proxyStarted-functions (lambda ()
            (writeStringToBuffer proxyProcess "Debugger proxy started\n")))

;; threadDied
(defvar jbug-threadDied-functions nil)
(setq jbug-threadDied-functions ())
(ht-set jbug-response-hash-table
   jbug-threadDied-response
   (lambda (response) (run-hook-with-args 'jbug-threadDied-functions  (-slice response 1 7))))

;;(add-functions 'jbug-threadDied-functions (lambda ( tr)

;; threadStarted
(defvar jbug-threadStarted-functions nil)
(setq jbug-threadStarted-functions ())
(ht-set jbug-response-hash-table
   jbug-threadStarted-response
   (lambda (response) (run-hook-with-args 'jbug-threadStarted-functions  (-slice response 1 7))))

;; threadStarted
;;(add-functions 'jbug-threadStarted-functionsn (lambda ( tr)

(defun jbug-LocationString (l) (format "%s:%s %s" (locationFile l) (locationLineNumber l) (locationMethod l)))


(defun setDotNotation(a)
  (setq a (s-trim a))
  (let ((b (if (string= a "") () (-take 6 (s-split "[.]" a)))))
    (while (< (length b) 6) (setq b (-snoc b "*")))
    (s-join "." b)))

#+END_SRC

** Provide

#+BEGIN_SRC emacs-lisp :tangle jbug.el

(provide 'jbug)

;;; jdb.el ends here
#+END_SRC
