* Java Debugger

*** compile the java agent

/home/jruby/tools/jdk1.8.0_131/bin/javac -cp ".:/home/jruby/tools/jdk1.8.0_131/lib/tools.jar" debugger.java

*** start the java agent

/home/jruby/tools/jdk1.8.0_131/bin/java -cp ".:/home/jruby/tools/jdk1.8.0_131/lib/tools.jar" debugger

*** COMMENT start the debugee 

/home/jruby/tools/jdk1.8.0_131/bin/java -cp ".:/home/jruby/tools/jdk1.8.0_131/lib/tools.jar" -agentlib:jdwp=transport=dt_socket,address=localhost:8000,server=y,suspend=y foo 3 4

#+BEGIN_SRC emacs-lisp :tangle yes
    (require 'ht)
    (require 's)
    (require 'bm)

    (defvar javadebug-mode-map
      (let ((map (make-sparse-keymap)))
        (define-key map (kbd "RET") 'javadebug-newline)
        (define-key map (kbd "M-p") 'javadebug-commandring)
        map))

    (defvar proxyProcess () "the JAVA proxy program which connects to the program to be debugged")
    (defvar defaultThread "" "the last thread in which we had a breakpoint. use this thread if no thread number is specified in a command")

    (defvar commandsToRun  () "list of commands to send to proxy")

    (defconst orgTableSeperator     "|----|\n"                                                                 "string to seperate table title from contents")
    (defconst localTableTitle         "Locals\n"                                                              "title tor local variables table")
    (defconst argumentsTableTitle "Arguments\n"                                                        "title for method arguments table")
    (defconst threadTableTitle       "|ID|Name|State|Frames|Breakpoint|Suspended|\n"    "title for thread table")

    (defconst sessionHeadline     "* "     "start of debugging session")
    (defconst breakpointHeadline "** "    "reports a breakpoint")
    (defconst commandHeadline  "*** "   "enter a command")

  (defcustom javadebug-mode-functions 'javadebug-proxy-string-received
    "Abnormal hook run on reception of a string from the proxy."
    :type 'hook
    :options '(javadebug-proxy-string-received)
    :group 'javadebug)

    (defconst commandList
      (list
       (list "attach"
             (lambda (c) (or (/= (length c) 3)  (not (string-match "[0-9]+" (nth 2 c)))))
             "attach host  [port number]"
             (lambda (c) (format "attach %s %s" (nth 1 c) (nth 2 c)))
             (lambda (r) (and (string= (car r) "vm")) (string= (nth 1 r) "started")))
       (list "back"
             (lambda (c) (or (> (length c) 2)  (and (= (length c) 2) (not (string-match "[0-9]+" (nth 1 c))))))
             "back [thread-id]"
             (lambda (c)
               (format
                "back %s"
                (if (= (length c) 1) defaultThread (nth 1 c))))
             (lambda (r) (string= (car r) "step")))
       (list "break"
             (lambda (c) (/= (length c) 3))
             "break class-name <line-number|method name>"
             (lambda (c) (format "break %s %s" (nth 1 c) (nth 2 c)))
             (lambda (r) (and (string= (car r) "break")) (string= (nth 1 r) "created")))
       (list "continue"
             (lambda (c) (/= (length c) 1))
             "continue"
             (lambda (c) (format "continue"))
             (lambda (r) (string= (car r) "resuming")))
       (list "frame"
             (lambda (c) (not (or (= (length c) 1)
                                   (and (= (length c) 2) (string-match "[0-9]+" (nth 1 c)))
                                   (and (= (length c) 3)  (string-match "[0-9]+" (nth 1 c))  (string-match "[0-9]+" (nth 2 c))))))
             "frame [thread-id] [frame number]"
             (lambda (c)
               (format
                "frame %s %s"
                (if (= (length c) 1) defaultThread (nth 1 c))
                (if (or (= (length c) 1)  (= (length c) 2) "0" (nth 2 c)))))
             (lambda (r) (string= (car r) "frame")))
       (list "into"
             (lambda (c) (or (> (length c) 2)  (and (= (length c) 2) (not (string-match "[0-9]+" (nth 1 c))))))
             "into [thread-id]"
             (lambda (c)
               (format
                "into %s"
                (if (= (length c) 1) defaultThread (nth 1 c))))
             (lambda (r) (string= (car r) "step")))
       (list "load"
             (lambda (c) (/= (length c) 1))
             "run"
             (lambda (c) (format "run"))
             (lambda (r) (string= (car r) "classloaded")))
       (list "next"
             (lambda (c) (or (> (length c) 2)  (and (= (length c) 2) (not (string-match "[0-9]+" (nth 1 c))))))
             "next [thread-id]"
             (lambda (c)
               (format
                "next %s"
                (if (= (length c) 1) defaultThread (nth 1 c))))
             (lambda (r) (string= (car r) "step")))
       (list "prepare"
             (lambda (c) (/= (length c) 2))
             "prepare [class name]"
             (lambda (c) (format "prepare %s" (nth 1 c)))
             (lambda (r) (string= (car r) "prepared")))
       (list "quit"
             (lambda (c) (/= (length c) 1))
             "quit"
             (lambda (c) "quit")
             (lambda (r) (string= (car r) "proxy"))) 
       (list "run"
             (lambda (c) (/= (length c) 1))
             "run"
             (lambda (c) (format "run"))
             (lambda (r) (string= (car r) "resuming")))
       (list "stack"
             (lambda (c) (or (> (length c) 2)  (not (string-match "[0-9]+" (nth 1 c)))))
             "stack [thread-id]"
             (lambda (c)
               (format
                "stack %s"
                (if (= (length c) 1) defaultThread (nth 1 c))))
             (lambda (r) (string= (car r) "stack")))
       (list "this"
             (lambda (c) (not (or (= (length c) 1)
                                  (and (= (length c) 2)  (string-match "[0-9]+" (nth 1 c)))
                                  (and (= (length c) 3)   (string-match "[0-9]+" (nth 1 c)) (string-match "[0-9]+" (nth 2 c))))))
             "this [thread-id] [frame number]"
             (lambda (c)
               (format
                "this %s %s"
                (if (= (length c) 1) defaultThread (nth 1 c))
                (if (or (= (length c) 1)  (= (length c) 2) "0" (nth 2 c)))))
             (lambda (r) (string= (car r) "this)")))
       (list "thread"
             (lambda (c) (or (> (length c) 2)  
                             (and (= (length c) 1)
                                  (not (string-match "[0-9]+" (nth 1 c)))
                                  (not (string-match "all" (nth 1 c))))))
             "thread [thread-id] or thread all"
             (lambda (c)
               (format
                "thread %s"
                (if (= (length c) 1) defaultThread (nth 1 c))))
             (lambda (r) (string= (car r) "thread"))))
      "all the commands we can send to the proxy")

    (defun commandName (e) (nth 0 e))
    (defun commandIsBadP (e f)  (funcall (nth 1 e) f))
    (defun commandTemplate (e) (nth 2 e))
    (defun commandFinalForm (e f)  (funcall (nth 3 e) f))
    (defun commandFinished (e f) (funcall (nth 4 e) f))

    (defvar commandHashMap () "hash map containing the contents of the commandList")
    (defvar runningCommand   () "the command which is active in the proxy")

    (define-derived-mode javadebug-mode
      org-mode "JavaDebug"
      "Major mode java debugger.")

    (defun startProc (px src mn)
      (interactive "Dproxy directory: \nDsource root:: \nMmain class ")
      (message "startProc")
      (goto-char (point-max))
      (insert (concat "\n\n" sessionHeadline "Starting debugger session " (current-time-string) ".\n\tProxy directory: " px ".\n\tSource root: " src ".\n\tMain class: " mn ".\n\n"));
      (cd (file-name-as-directory px))
      (delete-other-windows)
      (javadebug-mode)
      (add-hook 'javadebug-mode-functions 'javadebug-proxy-string-received)
      (setq sourceWindow (split-window-below))
      (setq jdbuggerString "")
      (setq javadebug-ring (make-ring 8))
      (setq javadebug-ring-index 0)
      (setq commandsToRun ())
      (setq commandHashMap (ht-create))

      (dolist (v commandList)
        (ht-set commandHashMap (commandName v) v))

      ;; wait until the proxy starts up

      (setq runningCommand
            (list
             ()
             (list "proxy"
                   (lambda (c) ())
                   ""
                   (lambda (c) "")
                   (lambda (r) (and (string= (car r) "proxy") (string= (nth 1 r) "started"))))
             ()))

      (javadebug-add-commands
       (list
        "attach localhost 8000"
        (concat "prepare " mn)
       "load"
       (concat "break " mn " main")
       "continue"))

      (setq proxyProcess
            (start-process 
             "jdbProxy" 
             (current-buffer)
             "/home/jruby/tools/jdk1.8.0_131/bin/java" 
             "-cp" 
             "/home/jruby/tmp/jdb/:/home/jruby/tools/jdk1.8.0_131/lib/tools.jar" 
             "debugger"))
      (set-process-filter proxyProcess 'javadebug-insertion-filter)
      (goto-char (point-max))
      (set-marker (process-mark proxyProcess) (point)))

    (defun javadebug-newline ()
      (interactive)
      (let ((com (buffer-substring-no-properties
                  (line-beginning-position)
                  (line-end-position))))
        (if (or 
             (/=  (line-end-position) (point-max))
             (not (string-match-p "[a-zA-Z0-9 ]+" com)))
            (org-return)
          (beginning-of-line)
          (ignore-errors (kill-line))  ;; kill-line signals an error at the end of buffer
          (javadebug-add-commands (split-string com ";" 't)))))

    (defun javadebug-add-commands (com)
      (let ((r (javadebug-check-commands com)))
        (if (javadebug-check-errors r)
            (dolist (v (javadebug-check-errors r))
              (writeStringToBuffer proxyProcess (concat v "\n")))
          (setq commandsToRun (append commandsToRun (javadebug-check-good-commands r)))
          (message "javadebug-add-commands commandsToRun %s runningCommand %s" commandsToRun runningCommand)
          (javadebug-execute-command))))

    (defun javadebug-check-commands (cm)
      (let ((checkErrors ())
            (goodCommands ()))
        (dolist (v cm)
          (let* ((c (split-string v " "  't))
                 (commandEntry (ht-get commandHashMap (car c))))
            (if (null commandEntry)
                (setq checkErrors (append checkErrors (list (concat "error - no such command: " v))))
              (if (commandIsBadP commandEntry c)
                  (setq checkErrors (append checkErrors (list (concat "error - bad command format " v ". Try "  (commandTemplate commandEntry)))))
                (setq goodCommands (append goodCommands (list (list c commandEntry))))
                (message "javadebug-check-commands c %s commandEntry %s goodCommands %s commandsToRun %s" c commandEntry goodCommands commandsToRun)))))
        (list goodCommands checkErrors)))

    (defun javadebug-check-good-commands (l) (nth 0 l))
    (defun javadebug-check-errors (l) (nth 1 l))

    (defun javadebug-command-split (l) (nth 0 l))
    (defun javadebug-command-entry (l) (nth 1 l))
    (defun javadebug-command-finished (l) (nth 2 l))

    (defun javadebug-execute-command ()
      (message "javadebug-execute-command 1 commandsToRun %s" commandsToRun)
      (if (and commandsToRun (null runningCommand))
          (let* ((c (car commandsToRun))
                 (finished ""))
            (setq commandsToRun (cdr commandsToRun))
            (message "javadebug-execute-command 1 commandsToRun %s" commandsToRun)
            (message "javadebug-execute-command c %s commandsToRun %s " c commandsToRun)
            (setq finished (commandFinalForm (javadebug-command-entry c) (javadebug-command-split c)))
            (message "javadebug-execute-command finished %s " finished)
            (ring-insert javadebug-ring finished)
            (writeStringToBuffer proxyProcess (concat "\n" commandHeadline finished "\n"))
            (setq runningCommand (list  (javadebug-command-split c) (javadebug-command-entry c) finished))
            (process-send-string proxyProcess (concat  finished "\n")))))

    (defun javadebug-commandring ()
      (interactive)
      (if (/=  (line-end-position) (point-max))
          (progn
            (goto-char (point-max))
            (insert "\n")
            (setq javadebug-ring-index 0))
        (beginning-of-line)
        (ignore-errors (kill-line))  ;; kill-line signals an error at the end of buffer
        (if (not (ring-empty-p javadebug-ring))
            (progn
              (if (>= javadebug-ring-index (ring-length javadebug-ring))
                  (setq javadebug-ring-index 0))
              (insert (ring-ref javadebug-ring javadebug-ring-index))
              (setq javadebug-ring-index (1+ javadebug-ring-index))))))

    (defun writeStringToBuffer (proc string)
      (when (buffer-live-p (process-buffer proc))
        (with-current-buffer (process-buffer proc)
          (save-excursion
            ;; Insert the text, advancing the process marker.
            (goto-char (point-max))
            (insert string)))))

    (defun writeOrgTableToBuffer (proc title sep rows)
      (when (buffer-live-p (process-buffer proc))
        (with-current-buffer (process-buffer proc)
          (save-excursion
            ;; Insert the text, advancing the process marker.
            (goto-char (point-max))
            (insert (concat "\n\n" title))
            (insert sep)
            (insert (dataLayout rows))
            (set-marker (process-mark proc) (point))
            (beginning-of-line 0)
            (org-ctrl-c-ctrl-c)))))

    (defun dataLayout (args)
      (if args
          (let ((s "| ")
                (stack ())
                (rc 0)
                (ac 0))
            (push (list rc args) stack)
            (while stack
              (cond
               ((not args)
                (let ((a (pop stack)))
                  (setq args (nth 1 a))
                  (setq rc     (nth 0 a))))
               ((listp (car args))
                (push (list rc (cdr args)) stack)
                (setq args (car args)))
               ((not (listp (car args)))
                (let ((v (car args)))
                  (setq args (cdr args))
                  (while (/= rc ac)
                    (cond
                     ((< ac rc)
                      (setq s (concat s " | "))
                      (setq ac (1+ ac)))
                     ((> ac rc)
                      (setq s (concat s "\n| "))
                      (setq ac 0))))
                  (setq s (concat s v))
                  (setq rc (1+ rc))))))
            s)
        ""))

    (defun javadebug-insertion-filter (proc string)
      (message "Received: %s :EndReceived %s" string commandsToRun)
      (setq jdbuggerString (concat jdbuggerString string))
      (if (s-ends-with? "\n" jdbuggerString)
          (let ((com (split-string jdbuggerString "\n" 't)))
            (message "javadebug-insertion-filter jdbuggerString: %s com %s" jdbuggerString com)
            (setq jdbuggerString ())
            (dolist (c com)
              (message "javadebug-insertion-filter c: %s com %s" c com)
              (if (not (s-blank? c)) (jdbAction proc c)))
            (when (and (buffer-live-p (process-buffer proc))
                       (get-buffer-window (process-buffer proc)))
              (select-window (get-buffer-window (process-buffer proc)))
              (goto-char (point-max))
              (insert "\n")))))

    (defun jdbAction (proc in)
      (message "jdbAction Processed: %s :EndProcessed\nrunningCommand %s commandsToRun %s" in runningCommand commandsToRun)
      (let ((args (split-string in ",")))
        (if (string= (car args) "error")
             (writeStringToBuffer proc (concat " "  in "\n")))
        (run-hook-with-args 'javadebug-mode-functions proc (car args) (cdr args))
        (if (and runningCommand
                 (or (string= (car args) "error")
                     (commandFinished (javadebug-command-entry runningCommand) args)))
            (progn
              (setq runningCommand ())
              (javadebug-execute-command)))))

    (defun javadebug-proxy-string-received (proc act args)
      (message "javadebug-proxy-string-received commandsToRun %s" commandsToRun)
      (cond 
       ((string= act "break")
        (if (string= (car args)  "created") 
            (writeStringToBuffer proc (concat "Breakpoint created at " (nth 1 args) "\n"))))
       ((string= act "breakpoint")
        (reportBreak args))
       ((string= act "classloaded")
        (writeStringToBuffer proc (concat "Class " (car args) " loaded.\n")))
       ((string= act "step")
        (reportBreak args))
       ((string= act "proxy")
        (if (string= "exit" (car args))
            (progn
              (delete-process proc)
              (writeStringToBuffer proc "Debugger proxy exited\n")))
        (if (string= "started" (car args))
            (writeStringToBuffer proc "Debugger proxy started\n")))
       ((string= act "vm")
        (if (string= "started" (car args))
            (writeStringToBuffer proc "virtual machine started\n")
          (if (string= "created" (car args))
              (writeStringToBuffer proc "virtual machine created\n"))))
       ((string= act "frame") )
       ((or (string= act "local") (string= act "argument"))
        (writeOrgTableToBuffer
         proc
         (if (string= act "local") localTableTitle argumentsTableTitle)
         ""
         (if (and args (car args)) (nth 0 (read-from-string (car args))) ())))
       ((string= act "resuming") 
        (writeStringToBuffer proc "virtual machine resuming operation.\n"))
       ((string= act "prepared") 
        (writeStringToBuffer proc (concat "class prepare request for" (nth 1 args) "\n")))
       ((string= act "thread")
        (let ((b ()))
          (while (and args (threadDescriptor args))
            (setq b (cons (list (threadID args)  (threadName args) (threadState args)  (threadFrames args)  (threadBreakpoint args) (threadSuspended args)) b))
            (setq args (skipThread args)))
          (writeOrgTableToBuffer proc threadTableTitle orgTableSeperator b)))
       (t (writeStringToBuffer proc (format "error - unknown response %s arguments %s \n" act (if args args "null"))))))

    (defun reportBreak (args)
      (setq defaultThread (threadID (breakpointThread args)))
      (writeStringToBuffer
       proc
       (concat
        breakpointHeadline
        act
        " in thread "
        (threadID (breakpointThread args))
        " at "              
        (locationFile (breakpointLocation args))
        ":"
        (locationLineNumber (breakpointLocation args))
        "\n"))
      (setSourceFileWindow
       proc
       (locationFile (breakpointLocation args))
       (locationLineNumber (breakpointLocation args))))

    (defun threadID (args) (nth 1 args))
    (defun threadName (args) (nth 2 args))
    (defun threadState (args) (nth 3 args))
    (defun threadFrames (args) (nth 4 args))
    (defun threadBreakpoint (args) (nth 5 args))
    (defun threadSuspended (args) (nth 6 args))

    (defun skipThread (args) (nthcdr 7 args))
    (defun threadDescriptor (args)
      (if (string= "thread" (car args))
          (-slice args 0 7)
        ()))

    (defun breakpointThread (args) (-slice args 0 7))
    (defun breakpointLocation (args) (-slice args  7 12))

    (defun locationFile (args) (nth 1 args))
    (defun locationLineNumber (args) (nth 2 args))
    (defun locationMethod (args) (nth 3 args))

    (defun nameValuePairName (args) (nth 0 args))
    (defun nameValuePairValue (args) (nth 1 args))
    (defun skipNameValuePair   (args) (nthcdr 2 args))

    (defun setSourceFileWindow (proc file line)
      (let ((bug (find-file-noselect file)))
        (when (and bug (buffer-live-p (process-buffer proc)))
          (with-current-buffer bug
            (goto-char (point-min))
            (forward-line (1- (string-to-number line)))
            (bm-remove-all-all-buffers)
            (bm-toggle))
          (with-current-buffer (process-buffer proc)
            (goto-char (point-max)))
          (if (= (length (window-list)) 1)
              (split-window))
          (winForOtherBuffer bug (process-buffer proc))
          (let ((procWin (winForOtherBuffer (process-buffer proc) bug)))
            (if procWin
                (select-window procWin))))))

    (defun winForOtherBuffer (buffer notbuffer)
      (let ((win (get-buffer-window buffer)))
        (when (not win)
          (let  ((wl (window-list)))
            (while (and wl (eq notbuffer (window-buffer (car wl))))
              (setq wl (cdr wl)))
            (setq win (if wl (car wl) (car (window-list))))
            (set-window-buffer win buffer)))
        win))
#+END_SRC

#+RESULTS:
: winForOtherBuffer




* Starting debugger session Thu Dec 21 10:32:40 2017.
	Proxy directory: /home/jruby/tmp/jdb/.
	Source root: /home/jruby/tmp/jdb/.
	Main class: test.foo.

Debugger proxy started

*** attach localhost 8000

virtual machine created

virtual machine started

*** prepare test.foo

class prepare request for

*** run

virtual machine resuming operation.

Class test.foo loaded.

*** break test.foo main

Breakpoint created at test.foo:10

*** continue

virtual machine resuming operation.

** breakpoint in thread 1 at test/foo.java:10

